<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Daily Log Export</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- ✅ 관리자 공통 CSS 유지 -->
  <link rel="stylesheet" href="./admin.css" />

<style>
  /* =========================================================
     Export 필터 카드
  ========================================================= */
  .export-card{
    background:#fff;
    border:1px solid rgba(15,23,42,0.10);
    border-radius:14px;
    padding:14px;
    box-shadow:0 10px 24px rgba(15,23,42,0.06);
  }
  .export-sections{ display:flex; flex-direction:column; gap:14px; }
  .search-block{
    border: 1px solid rgba(15,23,42,0.08);
    border-radius:12px;
    padding:12px;
    background: rgba(15,23,42,0.02);
  }
  .search-title{
    font-weight: 900;
    font-size: 0.95rem;
    color:#0f172a;
    margin: 0 0 10px;
  }
  .search-grid{
    display:grid;
    grid-template-columns: repeat(12, 1fr);
    gap:10px;
    align-items:end;
  }
  .fg{ display:flex; flex-direction:column; gap:6px; }
  .fg label{ font-weight:800; font-size:0.9rem; color:#111827; }
  .fg input{
    border:1px solid rgba(15,23,42,0.18);
    border-radius:10px;
    padding:10px 12px;
    font-size:14px;
    outline:none;
    background:#fff;
    height:40px;
  }
  .fg input[type="date"]{ padding:8px 10px; }

  .span-2{ grid-column: span 2; min-width:120px; }
  .span-4{ grid-column: span 4; min-width:200px; }
  .span-8{ grid-column: span 8; min-width:260px; }

  .actions{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .help-line{
    margin-top:10px;
    color:rgba(17,24,39,0.75);
    font-size:0.92rem;
    line-height:1.45;
  }
  @media (max-width: 980px){
    .span-2,.span-4,.span-8{ grid-column: span 12; min-width: 0; }
  }

  /* =========================================================
     탭 UI
  ========================================================= */
  .tabs{
    display:flex; gap:8px; align-items:center;
    margin: 12px 0 14px;
    flex-wrap: wrap;
  }
  .tab-btn{
    border: 1px solid rgba(15,23,42,0.14);
    background:#fff;
    padding: 8px 12px;
    border-radius: 999px;
    cursor:pointer;
    font-weight: 700;
  }
  .tab-btn.active{ background:#111827; color:#fff; border-color:#111827; }
  .tab-panel{ display:none; }
  .tab-panel.active{ display:block; }

  /* =========================================================
     월 요약 생성기 폼
  ========================================================= */
  .note-grid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-top: 10px;
  }
  @media (max-width: 900px){
    .note-grid{ grid-template-columns: 1fr; }
  }
  .card{
    background:#fff;
    border: 1px solid rgba(15,23,42,0.10);
    border-radius: 14px;
    padding: 14px;
    box-shadow: 0 10px 24px rgba(15,23,42,0.06);
  }
  .card h2{ margin:0 0 10px; font-size: 1.05rem; }
  .field{ display:flex; flex-direction: column; gap: 6px; margin: 10px 0; }
  .field label{ font-weight: 800; font-size: 0.92rem; color:#111827; }
  .field input, .field textarea{
    width:100%;
    border: 1px solid rgba(15,23,42,0.18);
    border-radius: 10px;
    padding: 10px 12px;
    font-size: 14px;
    outline: none;
    background:#fff;
  }
  .field textarea{ min-height: 120px; resize: vertical; }

  .row-actions{ display:flex; gap:8px; flex-wrap:wrap; margin-top: 10px; }

  /* =========================================================
     month-note 미리보기 스타일(포스트잇)
  ========================================================= */
  .month-note{
    margin: 10px 0 14px;
    padding: 12px 14px;
    border-radius: 10px;
    background: #fff7cc;
    border: 1px solid rgba(17,24,39,0.10);
    box-shadow: 0 8px 18px rgba(15,23,42,0.08);
    position: relative;
  }
  .month-note::before{
    content:"";
    position:absolute;
    top:-8px;
    left: 18px;
    width: 66px;
    height: 18px;
    border-radius: 6px;
    background: rgba(255,255,255,0.65);
    border: 1px solid rgba(17,24,39,0.08);
    transform: rotate(-2deg);
  }
  .month-note-title{ font-weight: 800; color: #111827; margin-bottom: 8px; }
  .month-note-tags{ display:flex; flex-wrap:wrap; gap:8px; }
  .month-note-tags .mtag{
    display:inline-block;
    padding: 4px 8px;
    border-radius: 999px;
    font-size: 0.85em;
    font-weight: 700;
    background: rgba(17,24,39,0.08);
    color:#111827;
  }
  .month-note-desc{ margin-top: 8px; font-size: 0.88em; color: rgba(17,24,39,0.75); }
  @media (max-width: 640px){
    .month-note{ padding: 12px; }
    .month-note::before{ left: 12px; }
  }

  /* =========================================================
     태그 검수 카드
  ========================================================= */
  .ev-card{
    border:1px solid rgba(15,23,42,0.10);
    border-radius:14px;
    padding:12px 12px 10px;
    background:#fff;
    box-shadow:0 10px 24px rgba(15,23,42,0.06);
  }

  /* ✅ hidden(비표시) 카드 그레이아웃 */
  .ev-card.is-hidden{
    background: #d1d5db !important;
    border-color: rgba(15,23,42,0.18);
    opacity: 0.62;
    filter: grayscale(1);
  }
  .ev-card.is-hidden .ev-title{ color: rgba(15,23,42,0.72); }
  .ev-card.is-hidden .ev-body{ color: rgba(17,24,39,0.65); }

  .ev-head{ display:flex; gap:10px; align-items:flex-start; justify-content:space-between; }
  .ev-title{ font-weight:900; color:#0f172a; line-height:1.25; }
  .ev-meta{ color:rgba(17,24,39,0.65); font-size:0.88rem; margin-top:4px; }
  .ev-body{
    margin-top:8px;
    color:rgba(17,24,39,0.86);
    font-size:0.95rem;
    line-height:1.45;
    white-space:pre-wrap;
  }
  .ev-tags{
    margin-top:10px;
    display:flex;
    flex-wrap:wrap;
    gap:10px 14px;
    align-items:center;
  }
  .tag-group{
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    padding:8px 10px;
    border-radius:12px;
    background:rgba(15,23,42,0.03);
    border:1px solid rgba(15,23,42,0.06);
  }
  .tag-item{ display:flex; gap:6px; align-items:center; font-weight:800; font-size:0.92rem; }
  .tag-item input{ transform: translateY(1px); }

  /* ✅ 비표시 토글(헤더 우측) */
  .hide-toggle{
    display:flex;
    gap:6px;
    align-items:center;
    font-weight:900;
    font-size:0.9rem;
    padding:4px 8px;
    border-radius:999px;
    background:rgba(15,23,42,0.05);
    border:1px solid rgba(15,23,42,0.10);
    user-select:none;
  }
  .ev-card.is-hidden .hide-toggle{
    background:rgba(239,68,68,0.10);
    border-color:rgba(239,68,68,0.22);
    color:#7f1d1d;
  }

  .tag-note{ display:none; gap:8px; align-items:center; margin-top:8px; }
  .tag-note input{
    width:min(520px, 100%);
    border: 1px solid rgba(15,23,42,0.18);
    border-radius:10px;
    padding:8px 10px;
    font-size:14px;
    outline:none;
    background:#fff;
    height:36px;
  }

  .save-pill{
    font-size:0.82rem;
    font-weight:800;
    padding:4px 8px;
    border-radius:999px;
    background:rgba(17,24,39,0.06);
    color:rgba(17,24,39,0.75);
    white-space:nowrap;
  }
  .save-pill.saving{ background:rgba(255,184,0,0.16); color:#7a4d00; }
  .save-pill.saved{ background:rgba(34,197,94,0.14); color:#0f5132; }
  .save-pill.err{ background:rgba(239,68,68,0.14); color:#7f1d1d; }

  /* =========================================================
     그룹(E-xxxxxx-xx) 편집 UI
  ========================================================= */
  .group-editor{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .group-editor input{
    border: 1px solid rgba(15,23,42,0.18);
    border-radius: 10px;
    padding: 6px 10px;
    font-size: 14px;
    background: #fff;
    height: 36px;
    outline: none;
    min-width: 220px;
    font-weight: 800;
  }
  .group-editor .btn-mini{
    border:1px solid rgba(15,23,42,0.14);
    background:#fff;
    padding:6px 10px;
    border-radius:10px;
    cursor:pointer;
    font-weight:900;
    height:36px;
  }
  .group-editor .btn-mini.primary{ background:#111827; color:#fff; border-color:#111827; }
  .group-editor .btn-mini.danger{
    background:rgba(239,68,68,0.10);
    border-color:rgba(239,68,68,0.25);
    color:#7f1d1d;
  }
  .tag-hint{ font-size: 0.82rem; color: rgba(17,24,39,0.6); font-weight: 700; margin-left: 6px; }

  /* =========================================================
     이벤트(날짜/제목/내용) 편집 UI
  ========================================================= */
  .ev-actions{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .btn-mini{
    border:1px solid rgba(15,23,42,0.14);
    background:#fff;
    padding:6px 10px;
    border-radius:10px;
    cursor:pointer;
    font-weight:900;
    height:34px;
    line-height:1;
  }
  .btn-mini.primary{ background:#111827; color:#fff; border-color:#111827; }
  .btn-mini.ghost{ background:rgba(15,23,42,0.04); }

  .ev-editor{
    display:none;
    margin-top:10px;
    padding:10px;
    border-radius:12px;
    background:rgba(15,23,42,0.02);
    border:1px solid rgba(15,23,42,0.08);
  }
  .ev-editor.open{ display:block; }
  .ev-edit-grid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:10px;
    margin-top:8px;
  }
  @media (max-width: 900px){
    .ev-edit-grid{ grid-template-columns: 1fr; }
  }
  .ev-edit-field{ display:flex; flex-direction:column; gap:6px; margin-top:10px; }
  .ev-edit-field label{ font-weight:900; font-size:0.9rem; color:#111827; }
  .ev-edit-field input, .ev-edit-field textarea{
    width:100%;
    border: 1px solid rgba(15,23,42,0.18);
    border-radius: 10px;
    padding: 10px 12px;
    font-size: 14px;
    outline: none;
    background:#fff;
  }
  .ev-edit-field textarea{ min-height: 160px; resize: vertical; white-space: pre-wrap; }
  .ev-edit-actions{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:10px; }
  .ev-edit-actions .tag-hint{ margin-left:0; }

  /* =========================================================
     새 이벤트 추가 탭
  ========================================================= */
  .add-grid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-top: 10px;
  }
  .tg-select{
    height:34px;
    padding:6px 10px;
    border-radius:10px;
    border:1px solid rgba(15,23,42,0.14);
    background:#fff;
    font-weight:700;
  }
  @media (max-width: 980px){
    .add-grid{ grid-template-columns: 1fr; }
  }
  .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  .add-preview{
    border:1px solid rgba(15,23,42,0.10);
    border-radius:12px;
    padding:12px;
    background:rgba(15,23,42,0.02);
    min-height: 180px;
    white-space: pre-wrap;
    word-break: break-word;
    font-size: 13px;
  }

  /* =========================================================
     Clipboard paste image zone (Tag review)
     - 기본은 숨김(display:none)
     - JS에서 보일 때 display:flex로 켜기
  ========================================================= */
  .paste-zone{
    border:1px dashed rgba(15,23,42,0.25);
    border-radius:10px;
    padding:10px 12px;
    background:#fff;
    min-height:44px;
    font-size:0.92rem;
    color:rgba(15,23,42,0.75);
  }
  .paste-zone:focus{ outline:2px solid rgba(37,99,235,0.25); }
  .paste-hint{ font-size:0.82rem; color:rgba(15,23,42,0.65); margin-top:6px; }

  .paste-preview{
    margin-top:8px;
    display:none;              /* ✅ 기본 숨김 */
    align-items:center;
    gap:10px;
  }
  .paste-preview a{
    font-size:0.82rem;
    font-weight:800;
    text-decoration:underline;
    white-space:nowrap;
  }
  .paste-preview img{
    width:72px;
    height:72px;
    border-radius:10px;
    object-fit:cover;
    display:block;
    flex:0 0 auto;
    border:1px solid rgba(15,23,42,0.12);
  }
  @media (max-width: 640px){
    .paste-preview img{ width:56px; height:56px; }
  }
</style>

</head>

<body>
  <div class="admin-shell">
    <div id="admin-header-slot"></div>

    <div class="admin-main">
      <aside id="admin-menu-slot" class="admin-sidebar"></aside>

      <main class="wrap">
        <h1>주요 사건, 이슈, 뉴스 월별 총정리</h1>
        <p class="desc">
          daily_events 시트 데이터를 블로그에 바로 붙여넣을 수 있는 HTML로 변환합니다.
          (월/일/ID/기간 필터 + 태그 검수/수정 + 이벤트 내용 수정 + 신규 추가)
        </p>

        <!-- ✅ 탭 -->
        <div class="tabs">
          <button class="tab-btn" data-tab="tab-add">새 이벤트 추가</button>
          <button class="tab-btn" data-tab="tab-tagging">태그 검수</button>
          <button class="tab-btn active" data-tab="tab-export">HTML코드 생성기</button>
          <button class="tab-btn" data-tab="tab-monthnote">월 요약 포스트잇 생성기</button>
        </div>

        <!-- =========================
             TAB 0: 새 이벤트 추가
        ========================= -->
        <section id="tab-add" class="tab-panel">
          <div class="card">
            <h2>새 이벤트 추가 (파이프 여러 줄 붙여넣기: 1행=1이벤트)</h2>
            <p class="desc" style="margin-top:6px;">
              형식(11칸 고정): <span class="mono">id|date_type|date_start|date_end|title|content_raw|party|is_foreign|country|tags|created_at</span><br/>
              - <b>id</b>가 <span class="mono">AUTO</span> 또는 빈칸이면, 서버가 <b>date_start 기준</b>으로 <span class="mono">YYMMDD-01</span>처럼 자동 생성합니다.<br/>
              - 저장 시 <b>date_type</b>은 start/end로 자동 계산됩니다. (end 있으면 range, 없으면 single)
            </p>

            <div class="add-grid">
              <div>
                <div class="field">
                  <label>입력 라인</label>
                  <textarea id="addLine" class="mono" style="min-height:180px;"
                    placeholder="AUTO|single|2026-01-14||제목|내용|gukhim|FALSE||important|2026-01-14 13:40"></textarea>
                </div>

                <div class="row-actions">
                  <button id="addSave" class="btn primary">시트에 저장</button>
                  <button id="addClear" class="btn">비우기</button>
                  <span id="addStatus" class="desc" style="margin-left:auto;"></span>
                </div>

                <p class="desc" style="margin-top:10px;">
                  ✅ 팁: GPT 출력에 <span class="mono">|</span>가 본문에 섞이면 열이 깨집니다. 본문(content_raw)에는 <span class="mono">|</span>를 쓰지 않는 게 안전합니다.
                </p>
              </div>

              <div>
                <div class="field">
                  <label>미리보기(파싱 결과)</label>
                  <div id="addPreview" class="add-preview mono">(아직 없음)</div>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- =========================
             TAB 1: 태그 검수
        ========================= -->
        <section id="tab-tagging" class="tab-panel">
          <div class="card">
            <h2>태그 검수</h2>
            <p class="desc" style="margin-top:6px;">
              아래 목록은 <b>현재 입력된 연/월/일/기간/id 필터</b> 값을 그대로 사용합니다.
              (Export 탭 입력값과 동일)
            </p>

            <div class="row-actions" style="margin-top:10px;">
                <button id="tgLoad" class="btn primary">목록 불러오기</button>
              
                <label style="display:flex; gap:8px; align-items:center; font-weight:700;">
                  <input id="tgOnlyEmpty" type="checkbox" />
                  태그 비어있는 것만
                </label>
              
                <!-- ✅ 추가: 숨김 보기 옵션 -->
                <label style="display:flex; gap:8px; align-items:center; font-weight:700;">
                  숨김
                  <select id="tgHiddenView" class="tg-select">
                    <option value="all" selected>전체(숨김 포함)</option>
                    <option value="exclude">숨김 제외</option>
                    <option value="only">숨김만</option>
                  </select>
                </label>
              
                <span id="tgStatus" class="desc" style="margin-left:auto;"></span>
              </div>

            <div id="tgCards" style="margin-top:12px; display:flex; flex-direction:column; gap:10px;"></div>
          </div>
        </section>

        <!-- =========================
             TAB 2: Daily Log Export
        ========================= -->
        <section id="tab-export" class="tab-panel active">
          <div class="export-card">
            <div class="export-sections">

              <div class="search-block">
                <div class="search-title">연도, 월, 일 검색</div>
                <div class="search-grid">
                  <div class="fg span-2">
                    <label for="year">연도</label>
                    <input id="year" type="number" value="2026" />
                  </div>

                  <div class="fg span-2">
                    <label for="month">월</label>
                    <input id="month" type="number" min="1" max="12" value="1" />
                  </div>

                  <div class="fg span-4">
                    <label for="day">일 (단일)</label>
                    <input id="day" type="date" />
                  </div>
                </div>
              </div>

              <div class="search-block">
                <div class="search-title">구체적 범위로 검색</div>
                <div class="search-grid">
                  <div class="fg span-4">
                    <label for="start">start</label>
                    <input id="start" type="date" />
                  </div>

                  <div class="fg span-4">
                    <label for="end">end</label>
                    <input id="end" type="date" />
                  </div>
                </div>
              </div>

              <div class="search-block">
                <div class="search-title">id로 검색(복수 가능)</div>
                <div class="search-grid">
                  <div class="fg span-8">
                    <label for="ids">id</label>
                    <input id="ids" type="text" placeholder="EVT001 또는 EVT001,EVT002" />
                  </div>
                </div>
              </div>

              <div class="actions">
                <button id="btnGenerate" class="btn primary">HTML 생성</button>
                <label style="display:flex; gap:8px; align-items:center; font-weight:800; margin-left:6px;">
                  <input id="includeMonthNote" type="checkbox" />
                  월 요약 포스트잇 포함
                </label>
                <button id="btnCopy" class="btn">복사</button>
                <button id="btnOpen" class="btn">요청 URL 열기</button>
                <button id="btnClear" class="btn">비우기</button>
              </div>

              <div class="help-line">
                - <b>day</b>를 입력하면 일별 추출이 우선 적용됩니다.<br/>
                - <b>start/end</b>는 기간 추출입니다. (start만 또는 end만도 가능)<br/>
                - <b>id</b>는 단일 또는 콤마로 여러 개 지정 가능합니다.
              </div>

            </div>
          </div>

          <textarea
            id="output"
            placeholder="여기에 daily-log HTML이 생성됩니다"
            style="width:100%; height:380px; margin-top:14px;"
          ></textarea>

          <p class="desc" style="margin-top:10px;">
            마지막 요청 URL: <span id="lastUrl" style="word-break:break-all;"></span>
          </p>
        </section>

        <!-- =========================
             TAB 3: 월 요약 포스트잇 생성기
        ========================= -->
        <section id="tab-monthnote" class="tab-panel">
          <div class="note-grid">
            <div class="card">
              <h2>입력</h2>

              <div class="field">
                <label>자동 추천 개수(Top N)</label>
                <input id="mnTopN" type="number" min="3" max="20" value="8" />
              </div>
                            
              <div class="field">
                <label>타이틀</label>
                <input id="mnTitle" type="text" placeholder="예) 1월 핵심 키워드" />
              </div>

              <div class="field">
                <label>키워드 (줄바꿈 또는 콤마로 입력)</label>
                <textarea id="mnTags" placeholder="예)
베네수엘라 공습
민주당 공천헌금 파문
이혜훈 후보자 논란"></textarea>
              </div>

              <div class="field">
                <label>하단 설명 (선택)</label>
                <input id="mnDesc" type="text" placeholder="예) ※ 한 달을 관통하는 이슈 키워드" />
              </div>

              <div class="row-actions">
                <button id="mnBuild" class="btn primary">코드 생성</button>
                <button id="mnCopy" class="btn">코드 복사</button>
                <button id="mnReset" class="btn">입력 초기화</button>
                <button id="mnAuto" class="btn">important 태그 자동 추천</button>
              </div>

              <p class="desc" style="margin-top:10px;">
                - 키워드는 최대 8개 정도가 보기 좋습니다.<br/>
                - 입력은 자동 저장됩니다.
              </p>
            </div>

            <div class="card">
              <h2>미리보기</h2>
              <div id="mnPreview"></div>

              <h2 style="margin-top:14px;">생성된 코드</h2>
              <textarea id="mnOutput" style="width:100%; height:220px;" placeholder="여기에 month-note 코드가 생성됩니다"></textarea>
            </div>
          </div>
        </section>

      </main>
    </div>
  </div>

  <!-- ✅ 반드시 포함해야 하는 공통 스크립트 유지 -->
  <script src="./admin-common.js"></script>

  <script>
    /* =========================
       공통: escape
    ========================= */
    function escHtml(s){
      return String(s ?? "")
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/\"/g,"&quot;")
        .replace(/'/g,"&#39;");
    }
    function escAttr(s){ return escHtml(s).replace(/\"/g,"&quot;"); }

    /* ✅ [추가] bool 파서 + hidden 판정 */
    function parseBool_(v){
      if (v === true) return true;
      if (v === false) return false;
      const s = String(v ?? "").trim().toLowerCase();
      return (s === "true" || s === "t" || s === "1" || s === "y" || s === "yes" || s === "on");
    }

    /* =========================
       탭 로직
    ========================= */
    const tabBtns = Array.from(document.querySelectorAll(".tab-btn"));
    const tabPanels = Array.from(document.querySelectorAll(".tab-panel"));

    function setActiveTab(tabId){
      tabBtns.forEach(b => b.classList.toggle("active", b.dataset.tab === tabId));
      tabPanels.forEach(p => p.classList.toggle("active", p.id === tabId));
      localStorage.setItem("CHEESE_ACTIVE_TAB", tabId);
    }

    tabBtns.forEach(btn => btn.addEventListener("click", () => setActiveTab(btn.dataset.tab)));
    const savedTab = localStorage.getItem("CHEESE_ACTIVE_TAB");
    if (savedTab && document.getElementById(savedTab)) setActiveTab(savedTab);

    /* =========================
       Daily Log Export
    ========================= */
    const API_BASE =
      "https://script.google.com/macros/s/AKfycbyuC0qHyRdDKL2fC5fmRy66l0y1baCLbXuf9pNlPh0rBde_HQMzaqQv5NK06H_n7WFk/exec";

    const el = {
      year: document.getElementById("year"),
      month: document.getElementById("month"),
      day: document.getElementById("day"),
      start: document.getElementById("start"),
      end: document.getElementById("end"),
      ids: document.getElementById("ids"),
      output: document.getElementById("output"),
      lastUrl: document.getElementById("lastUrl"),
      btnGenerate: document.getElementById("btnGenerate"),
      btnCopy: document.getElementById("btnCopy"),
      btnOpen: document.getElementById("btnOpen"),
      btnClear: document.getElementById("btnClear"),
    };

    let lastRequestUrl = "";

    el.btnGenerate.addEventListener("click", generate);
    el.btnCopy.addEventListener("click", copyOutput);
    el.btnOpen.addEventListener("click", openLastUrl);
    el.btnClear.addEventListener("click", () => {
        el.output.value = "";
        el.lastUrl.textContent = "";
        lastRequestUrl = "";
        el.day.value = "";
        el.start.value = "";
        el.end.value = "";
    });

    function buildUrl() {
      const year  = String(el.year.value || "").trim();
      const month = String(el.month.value || "").trim();
      const day   = String(el.day.value || "").trim();
      const start = String(el.start.value || "").trim();
      const end   = String(el.end.value || "").trim();
      const ids   = String(el.ids.value || "").trim();

      if (!day && !start && !end && (!year || !month)) {
        throw new Error("월 추출은 연도/월이 필요하고, 일별은 day가 필요하며, 기간은 start/end가 필요합니다. (start만 또는 end만도 가능)");
      }

      const params = new URLSearchParams();
      params.set("mode", "exportDailyLog");

      if (day) {
        params.set("day", day);
      } else if (start || end) {
        if (start) params.set("start", start);
        if (end) params.set("end", end);
      } else {
        params.set("year", year);
        params.set("month", month);
      }

      if (ids) params.set("id", ids);

      return `${API_BASE}?${params.toString()}`;
    }

    async function generate() {
      try {
        const url = buildUrl();
        lastRequestUrl = url;
        el.lastUrl.textContent = url;

        el.output.value = "생성 중...";

        const res = await fetch(url, {
          method: "GET",
          cache: "no-store",
          redirect: "follow",
          credentials: "omit"
        });
        if (!res.ok) throw new Error("API 호출 실패 (HTTP " + res.status + ")");

        const text = await res.text();

        if (text && /<!doctype html|<html/i.test(text)) {
          throw new Error("API가 HTML 화면을 반환했습니다. (서버 doGet(e) 분기/배포 확인 필요)");
        }

        const fixed = text.replace(/&lt;br\s*\/?&gt;/gi, "<br>");

        let outHtml = fixed || "<!-- empty -->";
        
        // ✅ 체크 시: month-note 코드를 앞에 붙임
        const include = document.getElementById("includeMonthNote")?.checked === true;
        if (include){
          // mnOutput이 비어있으면 현재 입력값으로 생성 시도
          const mnOutputEl = document.getElementById("mnOutput");
          let mnCode = String(mnOutputEl?.value || "").trim();
        
          if (!mnCode){
            try { buildMonthNote(); } catch(_){}
            mnCode = String(mnOutputEl?.value || "").trim();
          }
        
          if (mnCode){
            outHtml = mnCode + "\n\n" + outHtml;
          }
        }
        
        el.output.value = outHtml;
      } catch (e) {
        el.output.value = "";
        const msg = (e && e.message ? e.message : String(e));
        alert("HTML 생성 실패: " + msg + "\n\n(확인) '요청 URL 열기'로 새 탭에서 결과가 텍스트로 뜨는지 확인하세요.");
      }
    }

    async function copyOutput() {
      const val = (el.output.value || "").trim();
      if (!val) {
        alert("복사할 내용이 없습니다.");
        return;
      }
      try {
        await navigator.clipboard.writeText(el.output.value);
        alert("복사 완료");
      } catch (e) {
        el.output.focus();
        el.output.select();
        document.execCommand("copy");
        alert("복사 완료");
      }
    }

    function openLastUrl() {
      try {
        const url = buildUrl();
        lastRequestUrl = url;
        el.lastUrl.textContent = url;
        window.open(url, "_blank", "noopener,noreferrer");
      } catch (e) {
        alert("URL 생성 실패: " + (e && e.message ? e.message : String(e)));
      }
    }

    /* =========================
       월 요약 포스트잇 생성기
    ========================= */
    const mn = {
      title: document.getElementById("mnTitle"),
      tags: document.getElementById("mnTags"),
      desc: document.getElementById("mnDesc"),
      preview: document.getElementById("mnPreview"),
      output: document.getElementById("mnOutput"),
      build: document.getElementById("mnBuild"),
      copy: document.getElementById("mnCopy"),
      reset: document.getElementById("mnReset"),
      topN: document.getElementById("mnTopN"),
      auto: document.getElementById("mnAuto"),
    };

    const MN_KEY = "CHEESE_MONTH_NOTE_FORM";
    function loadMonthNote(){
      try{
        const saved = JSON.parse(localStorage.getItem(MN_KEY) || "{}");
        if (saved.title != null) mn.title.value = saved.title;
        if (saved.tags  != null) mn.tags.value  = saved.tags;
        if (saved.desc  != null) mn.desc.value  = saved.desc;
        if (saved.topN != null && mn.topN) mn.topN.value = saved.topN;
      }catch(_){ }
    }
    function saveMonthNote(){
      localStorage.setItem(MN_KEY, JSON.stringify({
        title: mn.title.value || "",
        tags:  mn.tags.value || "",
        desc:  mn.desc.value || "",
        topN: mn.topN ? (mn.topN.value || "8") : "8"
      }));
    }
    ["input","change"].forEach(evt=>{
      mn.title.addEventListener(evt, saveMonthNote);
      mn.tags.addEventListener(evt, saveMonthNote);
      mn.desc.addEventListener(evt, saveMonthNote);
      mn.topN.addEventListener(evt, saveMonthNote);
    });

    if ((mn.title.value || mn.tags.value || mn.desc.value).trim().length){
      buildMonthNote();
    }
    
    loadMonthNote();

    function parseTags(text){
      return String(text || "")
        .split(/\n|,/g)
        .map(t => t.trim())
        .filter(Boolean)
        .slice(0, 12);
    }

    function buildMonthNote(){
      const title = (mn.title.value || "").trim() || "월 핵심 키워드";
      const tags = parseTags(mn.tags.value);
      const desc = (mn.desc.value || "").trim();

      const tagHtml = tags.length
        ? tags.map(t => `    <span class="mtag">${escHtml(t)}</span>`).join("\n")
        : `    <span class="mtag">키워드를 입력하세요</span>`;

      const descHtml = desc
        ? `\n\n  <div class="month-note-desc">\n    ${escHtml(desc)}\n  </div>`
        : "";

      const html =
`<!-- ✅ 월 요약 포스트잇 (매달 1회) -->
<div class="month-note">
  <div class="month-note-title">${escHtml(title)}</div>
  <div class="month-note-tags">
${tagHtml}
  </div>${descHtml}
</div>`;

      mn.preview.innerHTML =
        `<div class="month-note">
          <div class="month-note-title">${escHtml(title)}</div>
          <div class="month-note-tags">
            ${tags.map(t => `<span class="mtag">${escHtml(t)}</span>`).join("")}
          </div>
          ${desc ? `<div class="month-note-desc">${escHtml(desc)}</div>` : ""}
        </div>`;

      mn.output.value = html;
    }

    mn.build.addEventListener("click", (e) => {
      e.preventDefault();
      buildMonthNote();
      saveMonthNote();
    });

    mn.copy.addEventListener("click", async (e) => {
      e.preventDefault();
      const val = (mn.output.value || "").trim();
      if (!val){ buildMonthNote(); }
      try{
        await navigator.clipboard.writeText(mn.output.value);
        alert("복사 완료");
      }catch(_){
        mn.output.focus();
        mn.output.select();
        document.execCommand("copy");
        alert("복사 완료");
      }
    });

    mn.reset.addEventListener("click", (e) => {
      e.preventDefault();
      mn.title.value = "";
      mn.tags.value = "";
      mn.desc.value = "";
      mn.preview.innerHTML = "";
      mn.output.value = "";
      localStorage.removeItem(MN_KEY);
    });

    if ((mn.title.value || mn.tags.value || mn.desc.value).trim().length){
      buildMonthNote();
    }

    /* =========================
       TAGGING (태그 검수 + 이벤트 편집)
    ========================= */
    const TG_ADMIN_KEY = ""; // Code.gs의 ADMIN_KEY와 동일하게(비우면 보호 없음)
    const BASE_UI = ["보수","진보","국제","이슈"];
    const BASE_DB_PREFIX = "중요-";
    const GROUP_RE = /^E-\d{6}-\d{2}$/;

    const tg = {
      load: document.getElementById("tgLoad"),
      onlyEmpty: document.getElementById("tgOnlyEmpty"),
      hiddenView: document.getElementById("tgHiddenView"), // ✅ 추가
      status: document.getElementById("tgStatus"),
      cards: document.getElementById("tgCards"),
    };

    const SAVE_DEBOUNCE_MS = 450;
    const saveTimers = new Map();

    tg.load.addEventListener("click", loadTagCards);
    tg.hiddenView.addEventListener("change", loadTagCards); // ✅ 옵션 바꾸면 바로 다시 로드(선택)

    function buildListUrl(){
      const year  = String(el.year.value || "").trim();
      const month = String(el.month.value || "").trim();
      const day   = String(el.day.value || "").trim();
      const start = String(el.start.value || "").trim();
      const end   = String(el.end.value || "").trim();
      const ids   = String(el.ids.value || "").trim();

      if (!day && !start && !end && (!year || !month)) {
        throw new Error("월 추출은 연도/월이 필요하고, 일별은 day가 필요하며, 기간은 start/end가 필요합니다. (start만 또는 end만도 가능)");
      }

      const params = new URLSearchParams();
      params.set("mode", "listEvents");
      params.set("limit", "300");

      if (day) {
        params.set("day", day);
      } else if (start || end) {
        if (start) params.set("start", start);
        if (end) params.set("end", end);
      } else {
        params.set("year", year);
        params.set("month", month);
      }
    
      // ✅ 추가: 숨김 포함 여부(서버의 includeHidden 파라미터)
      const view = tg.hiddenView ? tg.hiddenView.value : "all";
      params.set("includeHidden", view === "exclude" ? "false" : "true");
        
      if (ids) params.set("id", ids);
      if (TG_ADMIN_KEY) params.set("key", TG_ADMIN_KEY);

      return `${API_BASE}?${params.toString()}`;
    }

    // ✅ 재등록(AUTO) 후: 새 date_start가 현재 필터 범위 밖이면
    // 새로 생성된 카드가 목록에 안 보일 수 있음 → 필터를 자동 동기화
    function syncFiltersToDateStart_(dateStart){
      const ds = String(dateStart || "").trim();
      if (!ds) return false;
      
      
      // 1) YYYY-MM-DD → day 우선
      if (/^\d{4}-\d{2}-\d{2}$/.test(ds)){
      if (el.day) el.day.value = ds;
      if (el.start) el.start.value = "";
      if (el.end) el.end.value = "";
      if (el.year) el.year.value = "";
      if (el.month) el.month.value = "";
      return true;
      }
      
      
      // 2) YYYY-MM → year/month
      if (/^\d{4}-\d{2}$/.test(ds)){
      const y = ds.slice(0,4);
      const m = String(Number(ds.slice(5,7))); // 01 → 1
      if (el.year) el.year.value = y;
      if (el.month) el.month.value = m;
      if (el.day) el.day.value = "";
      if (el.start) el.start.value = "";
      if (el.end) el.end.value = "";
      return true;
      }
      
      
      // 3) YYYY → 기간으로 잡아줌(연/월 없이도 buildListUrl 통과)
      if (/^\d{4}$/.test(ds)){
      if (el.day) el.day.value = "";
      if (el.year) el.year.value = "";
      if (el.month) el.month.value = "";
      if (el.start) el.start.value = ds + "-01-01";
      if (el.end) el.end.value = ds + "-12-31";
      return true;
      }
    
    
    return false;
    }


    
    async function loadTagCards(){
      try{
        tg.status.textContent = "불러오는 중...";
        tg.cards.innerHTML = "";
    
        const url = buildListUrl();
        const res = await fetch(url, { method:"GET", cache:"no-store", credentials:"omit" });
        if (!res.ok) throw new Error("목록 API 실패 (HTTP " + res.status + ")");
    
        const data = await safeReadJson_(res);
        if (!data || data.ok !== true) throw new Error((data && data.error) ? data.error : "UNKNOWN_ERROR");
    
        const allItems = Array.isArray(data.items) ? data.items : [];
        let items = allItems.slice();
    
        // 태그 비어있는 것만
        if (tg.onlyEmpty.checked) {
          items = items.filter(it => !String(it.tags || "").trim());
        }
    
        // ✅ 숨김 보기 필터
        const view = tg.hiddenView ? tg.hiddenView.value : "all";
        if (view === "exclude") items = items.filter(it => it.hidden !== true);
        if (view === "only")    items = items.filter(it => it.hidden === true);
    
        const hiddenCnt = allItems.filter(it => it.hidden === true).length;
    
        tg.status.textContent =
          view === "all"     ? `${items.length}건 (숨김 ${hiddenCnt}건 포함)`
        : view === "exclude" ? `${items.length}건 (숨김 ${hiddenCnt}건 제외)`
        :                    `${items.length}건 (숨김만)`;
    
        tg.cards.innerHTML = items.map(it => renderEventCardHtml(it)).join("");
        items.forEach(it => bindEventCard(it));
      }catch(e){
        tg.status.textContent = "";
        alert("태그 검수 목록 불러오기 실패: " + (e && e.message ? e.message : String(e)));
      }
    }

    function parseTagsToArray(s){
      return String(s || "")
        .split(",")
        .map(x=>String(x).trim())
        .filter(Boolean);
    }

    function toDbBase(ui){ return `${BASE_DB_PREFIX}${ui}`; }
    function hasDbBase(arr, ui){ return arr.includes(toDbBase(ui)); }
    function addDbBase(arr, ui){
      const t = toDbBase(ui);
      if (arr.includes(t)) return arr;
      return arr.concat([t]);
    }
    function removeDbBase(arr, ui){
      const t = toDbBase(ui);
      return arr.filter(x => x !== t);
    }

    function getGroupTag(arr){
      for (const t of arr){
        const s = String(t||"").trim();
        if (GROUP_RE.test(s)) return s;
      }
      return "";
    }
    function removeGroupTags(arr){
      return arr.filter(t => !GROUP_RE.test(String(t||"").trim()));
    }

    function getTypedTagValue(arr, type){
      for (const t of arr){
        const s = String(t||"").trim();
        if (s === type) return "";
        if (s.startsWith(type + "-")) return s.slice(type.length + 1);
      }
      return null;
    }
    function removeTyped(arr, type){
      return arr.filter(t=>{
        const s = String(t||"").trim();
        return !(s === type || s.startsWith(type + "-"));
      });
    }
    function upsertTyped(arr, type, value){
      const kept = removeTyped(arr, type);
      const v = String(value || "").trim();
      return kept.concat([ v ? `${type}-${v}` : type ]);
    }

    function normalizeTagsArray(arr){
      const seen = new Set();
      const uniq = [];
      arr.forEach(t=>{
        const s = String(t||"").trim();
        if (!s) return;
        if (seen.has(s)) return;
        seen.add(s);
        uniq.push(s);
      });

      const baseOrder = BASE_UI.map(ui => toDbBase(ui));
      const typedOrder = ["economy","important","mourning","mourning"];

      const group = [];
      const base = [];
      const typed = [];
      const other = [];

      uniq.forEach(t=>{
        const s = String(t||"").trim();
        if (GROUP_RE.test(s)) { group.push(s); return; }
        if (baseOrder.includes(s)) { base.push(s); return; }

        const m = /^([a-z]+)(?:-.*)?$/i.exec(s);
        const tp = m ? String(m[1]).toLowerCase() : "";
        if (typedOrder.includes(tp)) { typed.push(s); return; }

        other.push(s);
      });

      const groupOne = group.length ? [group[0]] : [];

      const baseSorted = [];
      baseOrder.forEach(x=>{ if (base.includes(x)) baseSorted.push(x); });

      const typedSorted = [];
      const picked = new Set();
      typedOrder.forEach(tp=>{
        const found = typed.find(t=>{
          const m = /^([a-z]+)(?:-.*)?$/i.exec(t);
          const x = m ? String(m[1]).toLowerCase() : "";
          return x === tp;
        });
        if (found && !picked.has(tp)) { picked.add(tp); typedSorted.push(found); }
      });

      return groupOne.concat(baseSorted).concat(typedSorted).concat(other);
    }

    function showNote(root, type, on){
      const box = root.querySelector(`.tag-note[data-note="${type}"]`);
      if (!box) return;
      box.style.display = on ? "flex" : "none";
    }
    function focusNote(root, type){
      const input = root.querySelector(`.tag-note[data-note="${type}"] input`);
      if (input) input.focus();
    }
    function clearNote(root, type){
      const input = root.querySelector(`.tag-note[data-note="${type}"] input`);
      if (input) input.value = "";
    }

    function buildPreview(text){
      const s = String(text || "").replace(/\s+/g," ").trim();
      if (!s) return "<span style='color:rgba(17,24,39,0.55)'>내용 없음</span>";
      const cut = s.length > 220 ? (s.slice(0,220) + "…") : s;
      return escHtml(cut);
    }

    /* ✅ [추가] 서버에서 내려오는 hidden 컬럼 판정(필요시 여기만 수정) */
    function isHiddenItem_(it, tagsArr){
      // 서버 컬럼명이 hide/is_hidden/hidden 중 무엇이든 대응
      const v = (it && (it.hidden ?? it.is_hidden ?? it.hide));
      if (parseBool_(v)) return true;

      // (혹시 태그 기반이 섞여있다면 보조로 대응)
      if (Array.isArray(tagsArr) && tagsArr.includes("__HIDE")) return true;

      return false;
    }

    function renderEventCardHtml(it){
      const id = escAttr(it.id);
      const title = escHtml(it.title || "");
      const date = escHtml(it.date_start || "");
      const party = escHtml(it.party || "");

      const tags = parseTagsToArray(it.tags || "");
      const hidden = isHiddenItem_(it, tags);

      const hasBosu  = hasDbBase(tags, "보수");
      const hasJinbo = hasDbBase(tags, "진보");
      const hasIntl  = hasDbBase(tags, "국제");
      const hasIssue = hasDbBase(tags, "이슈");

      const ecoVal = getTypedTagValue(tags, "economy");
      const impVal = getTypedTagValue(tags, "important");
      const mouVal = getTypedTagValue(tags, "mourning");
      const ecoOn = ecoVal != null;
      const impOn = impVal != null;
      const mouOn = mouVal != null;

      const groupTag = getGroupTag(tags) || "";

      const pillId = `pill_${id}`;
      const noteEId = `note_e_${id}`;
      const noteIId = `note_i_${id}`;
      const noteMId = `note_m_${id}`;

      const contentPreview = buildPreview(it.content_raw || "");

      return `
      <div class="ev-card${hidden ? " is-hidden" : ""}" data-id="${id}" data-hidden="${hidden ? "1" : "0"}">
        <div class="ev-head">
          <div>
            <div class="ev-title">${title}</div>
            <div class="ev-meta">${date}${party ? " · " + party : ""} · ${id}</div>
          </div>
          <div class="ev-actions">
            <!-- ✅ [추가] 비표시 토글 -->
            <label class="hide-toggle" title="비표시(히든) 처리">
              <input type="checkbox" data-action="hide-toggle" ${hidden ? "checked" : ""}/>
              비표시
            </label>

            <span id="${pillId}" class="save-pill">대기</span>
            <button type="button" class="btn-mini ghost" data-action="edit-toggle">편집</button>
          </div>
        </div>

        <div class="ev-body">${contentPreview}</div>

        <div class="ev-editor" data-role="editor">
          <div class="ev-edit-grid">
            <div class="ev-edit-field">
              <label>date_start</label>
              <input data-role="edit-start" type="date" value="${escAttr(it.date_start || "")}" />
            </div>
            <div class="ev-edit-field">
              <label>date_end</label>
              <input data-role="edit-end" type="date" value="${escAttr(it.date_end || "")}" />
            </div>
          </div>

          <div class="ev-edit-field">
            <label>title</label>
            <input data-role="edit-title" type="text" value="${escAttr(it.title || "")}" />
          </div>

          <div class="ev-edit-field">
            <label>image_url</label>
            <input data-role="edit-image-url" type="url" placeholder="https://..." value="${escAttr(it.image_url || "")}" />
          </div>

            <div class="ev-edit-field">
              <div class="ev-edit-label">스크린샷 붙여넣기</div>
              <div class="paste-zone" data-role="paste-image" contenteditable="true" spellcheck="false" tabindex="0">여기를 클릭하고 Ctrl+V</div>
              <div class="paste-hint">✅ 이미지 붙여넣기(Ctrl+V)가 들어오면 Drive에 저장하고 <b>image_url</b>을 자동으로 채웁니다. (image_url 입력칸에서 Ctrl+V 해도 동일)</div>
              <div class="paste-preview" data-role="paste-preview"></div>
            </div>


          <div class="ev-edit-field">
            <label>content_raw</label>
            <textarea data-role="edit-content">${escHtml(it.content_raw || "")}</textarea>
          </div>

          <div class="ev-edit-actions">
          <button type="button" class="btn-mini primary" data-action="edit-save">저장</button>
          <button type="button" class="btn-mini" data-action="edit-cancel">취소</button>
          
          
          <!-- ✅ 새 id 재생성(appendEvent AUTO) + 기존 숨김(patchHidden) -->
          <button type="button" class="btn-mini" data-action="edit-recreate">재등록(AUTO)</button>
          
          
          <span class="tag-hint">※ 저장 시 date_type은 start/end로 자동 계산 · 재등록은 새 id 생성 후 기존 건을 비표시 처리</span>
          </div>
        </div>

        <div class="ev-tags">
          <div class="tag-group">
            <label class="tag-item"><input type="checkbox" data-tg="base" data-key="보수" ${hasBosu ? "checked":""}/>보수</label>
            <label class="tag-item"><input type="checkbox" data-tg="base" data-key="진보" ${hasJinbo ? "checked":""}/>진보</label>
            <label class="tag-item"><input type="checkbox" data-tg="base" data-key="국제" ${hasIntl ? "checked":""}/>국제</label>
            <label class="tag-item"><input type="checkbox" data-tg="base" data-key="이슈" ${hasIssue ? "checked":""}/>이슈</label>
            <span class="tag-hint">(DB: 중요-*)</span>
          </div>

          <div class="tag-group">
            <label class="tag-item"><input type="checkbox" data-tg="typed" data-key="economy" ${ecoOn ? "checked":""}/>economy</label>
            <label class="tag-item"><input type="checkbox" data-tg="typed" data-key="important" ${impOn ? "checked":""}/>important</label>
            <label class="tag-item"><input type="checkbox" data-tg="typed" data-key="mourning" ${mouOn ? "checked":""}/>mourning</label>
          </div>

          <div class="tag-group">
            <span style="font-weight:900;">서브카드 그룹</span>
            <div class="group-editor" data-tg="group">
              <input data-role="group-input" type="text" placeholder="예) E-202601-01" value="${escAttr(groupTag)}" />
              <button type="button" class="btn-mini primary" data-action="group-apply">적용</button>
              <button type="button" class="btn-mini danger" data-action="group-clear">해제</button>
              <span class="tag-hint">E-xxxxxx-xx (1개 유지)</span>
            </div>
          </div>
        </div>

        <div class="tag-note" data-note="economy" style="${ecoOn ? "display:flex;" : ""}">
          <b style="min-width:82px;">economy</b>
          <input id="${noteEId}" type="text" placeholder="예) 환율/금리/유가" value="${escAttr(ecoVal || "")}" />
        </div>

        <div class="tag-note" data-note="important" style="${impOn ? "display:flex;" : ""}">
          <b style="min-width:82px;">important</b>
          <input id="${noteIId}" type="text" placeholder="예) 왜 중요한지 한 줄" value="${escAttr(impVal || "")}" />
        </div>

        <div class="tag-note" data-note="mourning" style="${mouOn ? "display:flex;" : ""}">
          <b style="min-width:82px;">mourning</b>
          <input id="${noteMId}" type="text" placeholder="예) 확산/증폭 포인트" value="${escAttr(mouVal || "")}" />
        </div>

        <textarea data-role="tags-raw" style="display:none;">${escHtml(tags.join(","))}</textarea>
      </div>
      `;
    }

    function scheduleSave(id, tagsArr, pillEl){
      if (saveTimers.has(id)) clearTimeout(saveTimers.get(id));

      pillEl.classList.remove("saved","err");
      pillEl.classList.add("saving");
      pillEl.textContent = "저장중";

      const timer = setTimeout(async ()=>{
        try{
          const ok = await postPatchTags(id, tagsArr.join(","));
          if (!ok) throw new Error("SAVE_FAILED");

          pillEl.classList.remove("saving","err");
          pillEl.classList.add("saved");
          pillEl.textContent = "저장됨";
        }catch(e){
          pillEl.classList.remove("saving","saved");
          pillEl.classList.add("err");
          pillEl.textContent = "오류";
        }
      }, SAVE_DEBOUNCE_MS);

      saveTimers.set(id, timer);
    }

    async function postPatchTags(id, tags){
      const params = new URLSearchParams();
      params.set("mode","patchTags");
      if (TG_ADMIN_KEY) params.set("key", TG_ADMIN_KEY);
      const url = `${API_BASE}?${params.toString()}`;

      try{
        const body = new URLSearchParams();
        body.set('id', String(id||''));
        body.set('tags', String(tags||''));

        const res = await fetch(url, {
          method:"POST",
          body,
          cache:"no-store",
          credentials:"omit"
        });

        if (res.ok){
          const data = await safeReadJson_(res);
          if (data && data.ok === true) return true;
        }
      }catch(_){ }

      return false;
    }

    async function postPatchEvent(id, patch){
      const params = new URLSearchParams();
      params.set('mode','patchEvent');
      if (TG_ADMIN_KEY) params.set('key', TG_ADMIN_KEY);
      const url = `${API_BASE}?${params.toString()}`;
    
      try{
        const body = new URLSearchParams();
        body.set('id', String(id||''));
        if (patch && patch.date_start != null) body.set('date_start', String(patch.date_start||''));
        if (patch && patch.date_end != null)   body.set('date_end', String(patch.date_end||''));
        if (patch && patch.title != null)      body.set('title', String(patch.title||''));
        if (patch && patch.content_raw != null)body.set('content_raw', String(patch.content_raw||''));
        if (patch && patch.image_url != null)  body.set('image_url', String(patch.image_url||''));
    
        const res = await fetch(url, { method:'POST', body, cache:'no-store', credentials:'omit' });
        const text = await res.text();
    
        // JSON 파싱 시도
        let data = null;
        try { data = JSON.parse(text); } catch(_){}
    
        if (!res.ok){
          return { ok:false, error:`HTTP ${res.status}: ${text.slice(0,300)}` };
        }
        if (!data){
          return { ok:false, error:`JSON 아님: ${text.slice(0,300)}` };
        }
        if (data.ok !== true){
          return { ok:false, error: String(data.error || JSON.stringify(data)).slice(0,300) };
        }
        return { ok:true, data };
      }catch(e){
        return { ok:false, error: e && e.message ? e.message : String(e) };
      }
    }

    // ✅ 재발급(덮어쓰기): date_start 기준으로 id까지 재산정
    async function postReissueEvent(id, patch, force){
      const params = new URLSearchParams();
      params.set('mode','reissueEvent');
      if (TG_ADMIN_KEY) params.set('key', TG_ADMIN_KEY);
      const url = `${API_BASE}?${params.toString()}`;
    
      try{
        const body = new URLSearchParams();
        body.set('id', String(id||''));
        if (patch && patch.date_start != null) body.set('date_start', String(patch.date_start||''));
        if (patch && patch.date_end != null)   body.set('date_end', String(patch.date_end||''));
        if (patch && patch.title != null)      body.set('title', String(patch.title||''));
        if (patch && patch.content_raw != null)body.set('content_raw', String(patch.content_raw||''));
        if (patch && patch.image_url != null)  body.set('image_url', String(patch.image_url||''));
        if (force === true) body.set('force', 'true');
    
        const res = await fetch(url, { method:'POST', body, cache:'no-store', credentials:'omit' });
        const text = await res.text();
    
        let data = null;
        try { data = JSON.parse(text); } catch(_){}
    
        if (!res.ok) return { ok:false, error:`HTTP ${res.status}: ${text.slice(0,300)}` };
        if (!data)  return { ok:false, error:`JSON 아님: ${text.slice(0,300)}` };
        if (data.ok !== true) return { ok:false, error: String(data.error || JSON.stringify(data)).slice(0,300) };
    
        return { ok:true, data };
      }catch(e){
        return { ok:false, error: e && e.message ? e.message : String(e) };
      }
    }

    async function postUploadImage(id, title, mime, base64){
      const params = new URLSearchParams();
      params.set('mode','uploadImage');
      if (TG_ADMIN_KEY) params.set('key', TG_ADMIN_KEY);
      const url = `${API_BASE}?${params.toString()}`;

      // ✅ 디버그용: 원문/상태코드까지 항상 확보
      const mkErr = (label, extra) => {
        const parts = [];
        if (label) parts.push(String(label));
        if (extra && typeof extra === 'object'){
          try{ parts.push(JSON.stringify(extra)); }catch(_){ parts.push(String(extra)); }
        }else if (extra != null){
          parts.push(String(extra));
        }
        return parts.join(' | ').slice(0, 2000);
      };

      try{
        // ✅ JSON 금지: preflight(OPTIONS) 안 생기게 "폼 전송"으로 보냄
        const body = new URLSearchParams();
        body.set('id', String(id||''));
        body.set('title', String(title||''));
        body.set('mime', String(mime||''));
        body.set('data', String(base64||''));

        const res = await fetch(url, {
          method:'POST',
          body,                 // ✅ form-urlencoded
          cache:'no-store',
          credentials:'omit'    // 유지
          // ✅ headers 설정하지 말 것!
        });

        const text = await res.text();
        let data = null;
        try { data = JSON.parse(text); } catch(_){ }

        // ✅ 콘솔에 최소 정보 남김(알림이 짧아도 원인 추적 가능)
        try{
          console.log('[uploadImage] url=', url);
          console.log('[uploadImage] status=', res.status);
          console.log('[uploadImage] raw=', (text||'').slice(0, 500));
        }catch(_){ }

        if (!res.ok){
          return { ok:false, error: mkErr(`HTTP ${res.status}`, (data ? data : String(text || '').slice(0,500))), raw:text, status:res.status, url };
        }

        if (!data){
          return { ok:false, error: mkErr('JSON_PARSE_FAILED', String(text || '').slice(0,500)), raw:text, status:res.status, url };
        }

        if (data.ok !== true) {
          const msg = (data && data.detail)
            ? `${data.error}: ${data.detail}`
            : (data && data.error ? String(data.error) : 'UPLOAD_FAILED');

          return { ok:false, error: mkErr('API_ERROR', { msg, build: data._build, ts: data._ts }), raw:text, status:res.status, url, data };
        }

        return { ok:true, data, raw:text, status:res.status, url };
      }catch(e){
        const msg = e && e.message ? e.message : String(e);
        return { ok:false, error: mkErr('FETCH_ERROR', msg), status:0, url };
      }
    }


    
    function safePipe_(s){
      // | 가 들어가면 11칸 파싱이 깨지므로 치환
      return String(s ?? "").replaceAll("|", "｜");
      }
      
      
      async function postAppendEventLine(line){
      const params = new URLSearchParams();
      params.set('mode','appendEvent');
      if (TG_ADMIN_KEY) params.set('key', TG_ADMIN_KEY);
      const url = `${API_BASE}?${params.toString()}`;
      
      
      try{
      const body = new URLSearchParams();
      body.set('line', String(line || ''));
      
      
      const res = await fetch(url, { method:'POST', body, cache:'no-store', credentials:'omit' });
      const text = await res.text();
      
      
      let data = null;
      try { data = JSON.parse(text); } catch(_){ }
      
      
      if (!res.ok) return { ok:false, error:`HTTP ${res.status}: ${text.slice(0,300)}` };
      if (!data) return { ok:false, error:`JSON 아님: ${text.slice(0,300)}` };
      if (data.ok !== true) return { ok:false, error: String(data.error || JSON.stringify(data)).slice(0,300) };
      
      
      // Apps Script appendEvent 성공 시 {ok:true, id:"YYMMDD-##"} 형태
      return { ok:true, id: String(data.id || '') };
      
      
      }catch(e){
      return { ok:false, error: e && e.message ? e.message : String(e) };
      }
    }

    
    async function postPatchHidden(id, hidden){
      const params = new URLSearchParams();
      params.set('mode','patchHidden');
      if (TG_ADMIN_KEY) params.set('key', TG_ADMIN_KEY);
      const url = `${API_BASE}?${params.toString()}`;
    
      try{
        const body = new URLSearchParams();
        body.set('id', String(id||''));
        body.set('hidden', hidden ? 'true' : 'false');
    
        const res = await fetch(url, { method:'POST', body, cache:'no-store', credentials:'omit' });
        const text = await res.text();
    
        let data = null;
        try { data = JSON.parse(text); } catch(_){}
    
        if (!res.ok) return { ok:false, error:`HTTP ${res.status}: ${text.slice(0,300)}` };
        if (!data)    return { ok:false, error:`JSON 아님: ${text.slice(0,300)}` };
        if (data.ok !== true) return { ok:false, error: String(data.error || JSON.stringify(data)).slice(0,300) };
    
        return { ok:true, data };
      }catch(e){
        return { ok:false, error: e && e.message ? e.message : String(e) };
      }
    }
 
    function bindEventCard(it){
      const root = tg.cards.querySelector(`.ev-card[data-id="${CSS.escape(it.id)}"]`);
      if (!root) return;

      const pill = root.querySelector(`#pill_${CSS.escape(it.id)}`);

      const editor = root.querySelector('[data-role="editor"]');
      const btnToggle = root.querySelector('[data-action="edit-toggle"]');
      const btnSave = root.querySelector('[data-action="edit-save"]');
      const btnCancel = root.querySelector('[data-action="edit-cancel"]');
      const inStart = root.querySelector('[data-role="edit-start"]');
      const inEnd = root.querySelector('[data-role="edit-end"]');
      const inTitle = root.querySelector('[data-role="edit-title"]');
      const inContent = root.querySelector('[data-role="edit-content"]');
      const inImageUrl = root.querySelector('[data-role="edit-image-url"]');
      const pasteZone = root.querySelector('[data-role="paste-image"]');
      const pastePreview = root.querySelector('[data-role="paste-preview"]');

      const btnRecreate = root.querySelector('[data-action="edit-recreate"]');
      
      const uiTitle = root.querySelector('.ev-title');
      const uiMeta = root.querySelector('.ev-meta');
      const uiBody = root.querySelector('.ev-body');

      /* ✅ [추가] 비표시 토글 */
      const hideChk = root.querySelector('[data-action="hide-toggle"]');
      const applyHiddenUi = (on) => {
        root.classList.toggle('is-hidden', !!on);
        root.dataset.hidden = on ? '1' : '0';
      };
      let originalHidden = !!(hideChk && hideChk.checked);
      applyHiddenUi(originalHidden);

      const setPill = (state, text) => {
        if (!pill) return;
        pill.classList.remove('saving','saved','err');
        if (state) pill.classList.add(state);
        pill.textContent = text;
      };

      // ✅ Google Drive URL에서 파일 ID 추출 & 썸네일 URL 생성
      const driveIdFromUrl_ = (u) => {
        const s = String(u || '');
        // 1) ...?id=FILE_ID
        let m = s.match(/[?&]id=([a-zA-Z0-9_-]{10,})/);
        if (m && m[1]) return m[1];
        // 2) /d/FILE_ID/...
        m = s.match(/\/d\/([a-zA-Z0-9_-]{10,})(?:[/?]|$)/);
        if (m && m[1]) return m[1];
        return '';
      };
      const toDriveThumbUrl_ = (u) => {
        const id = driveIdFromUrl_(u);
        if (!id) return '';
        // Drive가 썸네일을 만들어주는 엔드포인트(공유 권한이 있어야 표시됨)
        return `https://drive.google.com/thumbnail?id=${id}&sz=w200`;
      };

      // ✅ image_url → 미리보기 동기화
      const renderImagePreview = (rawUrl) => {
        if (!pastePreview) return;
      
        const url = String(rawUrl || "").trim();
        if (!url) {
          pastePreview.style.display = "none";
          pastePreview.innerHTML = "";
          return;
        }

        const thumb = toDriveThumbUrl_(url) || url;
        pastePreview.style.display = "flex"; // ✅ CSS와 맞춰 flex로 표시
        pastePreview.innerHTML = `
          <a href="${escAttr(url)}" target="_blank" rel="noopener">원본 열기</a>
          <img src="${escAttr(thumb)}" alt="" loading="lazy" />
        `;

        // ✅ 썸네일이 깨지는 경우(권한/URL 문제) - 링크는 유지하고 힌트만 표시
        const img = pastePreview.querySelector('img');
        if (img){
          img.addEventListener('error', ()=>{
            try{ img.remove(); }catch(_){ }
            pastePreview.insertAdjacentHTML('beforeend', '<span class="tag-hint">미리보기 실패</span>');
          }, { once:true });
        }
      };
      
      // clipboard paste(image) -> upload -> fill image_url -> save (image_url only)
      const handleImagePaste = async (e)=>{
        try{
          // 중복 실행 방지(캡처/버블 중첩 등)
          if (e && e.__dlImgHandled) return;

          const items = (e.clipboardData && e.clipboardData.items) ? Array.from(e.clipboardData.items) : [];
          const imgItem = items.find(x => x && x.type && x.type.indexOf('image/') === 0);
          if (!imgItem) return; // 텍스트 붙여넣기는 그대로 통과

          // 이제부터는 “이미지 붙여넣기”로 처리
          e.__dlImgHandled = true;
          e.preventDefault();
          e.stopPropagation();

          setPill('saving','업로드중');

          const blob = imgItem.getAsFile();
          const mime = blob && blob.type ? blob.type : 'image/png';
          const b64 = await readBlobAsBase64_(blob);

          const curTitle = String(inTitle?.value || it.title || '').trim();
          const up = await postUploadImage(it.id, curTitle, mime, b64);
          if (!up || up.ok !== true){
            const dbg = up ? (up.error || JSON.stringify(up).slice(0,800)) : 'NO_RESPONSE';
            throw new Error(String(dbg || 'UPLOAD_FAILED'));
          }

          const url = String(up.data && up.data.url ? up.data.url : '').trim();
          if (!url) throw new Error('URL_EMPTY');

          if (inImageUrl) inImageUrl.value = url;

          // ✅ 미리보기 즉시 갱신
          renderImagePreview(url);
          
          // ✅ image_url만 DB에 즉시 반영(다른 필드 덮어쓰기 방지)
          const saved = await postPatchEvent(it.id, { image_url: url });
          if (!saved.ok) throw new Error(saved.error || 'PATCH_FAILED');
          
          // ✅ 취소/재로딩 시 안 사라지게 스냅샷도 갱신
          original.image_url = url;
          it.image_url = url;
          if (!saved.ok) throw new Error(saved.error || 'PATCH_FAILED');

          setPill('saved','업로드됨');
        }catch(err){
          setPill('err','오류');
          console.log('upload debug(err)=', err);
          alert('이미지 업로드 실패: ' + (err && err.message ? err.message : String(err)));
        }
      };

      // ✅ 어디에 커서가 있어도(특히 image_url input) 이미지 붙여넣기가 동작하도록
      if (pasteZone) pasteZone.addEventListener('paste', handleImagePaste);
      if (inImageUrl) inImageUrl.addEventListener('paste', handleImagePaste);
      // 카드 영역 어디서든 Ctrl+V 가능(텍스트는 통과, 이미지일 때만 업로드)
      root.addEventListener('paste', handleImagePaste, true);

      if (inImageUrl) {
        inImageUrl.addEventListener('input', () => {
          renderImagePreview(inImageUrl.value);
        });
        inImageUrl.addEventListener('change', () => {
          renderImagePreview(inImageUrl.value);
        });
      }
      

      if (hideChk){
          hideChk.addEventListener('change', async ()=>{
          const on = !!hideChk.checked;
          applyHiddenUi(on);
          setPill('saving','저장중');
        
          const r = await postPatchHidden(it.id, on);
        
          if (r.ok){
            setPill('saved','저장됨');
            originalHidden = on;
          }else{
            setPill('err','오류');
            alert('비표시 저장 실패: ' + r.error);
        
            // 실패 시 원복
            hideChk.checked = originalHidden;
            applyHiddenUi(originalHidden);
          }
        });
      }

      const snap = () => ({
        date_start: String(inStart?.value || '').trim(),
        date_end: String(inEnd?.value || '').trim(),
        title: String(inTitle?.value || '').trim(),
        content_raw: String(inContent?.value || ''),
        image_url: String(inImageUrl?.value || '').trim(),
        hidden: !!(hideChk && hideChk.checked)
      });
      let original = snap();
      renderImagePreview(original.image_url); // ✅ 카드 로드 시 기존 이미지도 표시

      const openEditor = (on) => {
        if (!editor) return;
        editor.classList.toggle('open', !!on);
        if (on) {
          original = snap();
          renderImagePreview(original.image_url); // ✅ 열 때도 동기화
        }
      };
if (btnToggle){
        btnToggle.addEventListener('click', ()=>{
          const isOpen = editor && editor.classList.contains('open');
          openEditor(!isOpen);
        });
      }

      if (btnCancel){
        btnCancel.addEventListener('click', ()=>{
          if (inStart) inStart.value = original.date_start || '';
          if (inEnd) inEnd.value = original.date_end || '';
          if (inTitle) inTitle.value = original.title || '';
          if (inContent) inContent.value = original.content_raw || '';
          if (inImageUrl) inImageUrl.value = original.image_url || '';

          if (hideChk){
            hideChk.checked = !!original.hidden;
            applyHiddenUi(!!original.hidden);
          }
          renderImagePreview(original.image_url); // ✅ 취소 시 미리보기 원복

          openEditor(false);
        });
      }

    if (btnRecreate){
      btnRecreate.addEventListener('click', async ()=>{
        try{
          const cur = snap();
    
          // 최소 검증
          if (!cur.title){ alert('title은 필수입니다.'); return; }
          if (!String(cur.date_start||'').trim() && String(cur.date_end||'').trim()){
            alert('date_end를 쓰려면 date_start가 필요합니다.');
            return;
          }
    
          setPill('saving','재발급중');
    
          // ✅ 같은 행을 “대체(덮어쓰기)”하면서, date_start 기준으로 id까지 재산정
          // - force=true: 버튼을 누른 경우에는 같은 날짜여도 새 id를 발급
          const r = await postReissueEvent(it.id, {
            date_start: cur.date_start || '',
            date_end: cur.date_end || '',
            title: cur.title || '',
            content_raw: cur.content_raw || '',
            image_url: cur.image_url || ''
          }, true);
    
          if (!r.ok) throw new Error(r.error || 'reissueEvent 실패');
    
          const newId = String(r.data?.new_id || '');
          const oldId = String(r.data?.old_id || String(it.id||''));
    
          setPill('saved', (newId && newId !== oldId) ? `재발급됨 → ${newId}` : '저장됨');
    
          // ✅ 새 date_start 기준으로 필터 동기화 (필터 밖이면 카드가 안 보일 수 있음)
          syncFiltersToDateStart_(cur.date_start);
    
          // id가 바뀌면 현재 카드의 data-id도 갱신(리렌더 전까지라도 일관성 유지)
          if (newId) root.dataset.id = newId;
    
          // 정렬/표시 보장: 목록 새로고침
          if (typeof loadTagCards === 'function'){
            await loadTagCards();
          }
        }catch(e){
          setPill('err','오류');
          alert('재발급 실패: ' + (e && e.message ? e.message : String(e)));
        }
      });
    }

      
      
      if (btnSave){
        btnSave.addEventListener('click', async ()=>{
          try{
            const cur = snap();
            if (!cur.title){
              alert('title은 비울 수 없습니다.');
              return;
            }
            if (!cur.date_start && cur.date_end){
              alert('date_end를 쓰려면 date_start가 필요합니다.');
              return;
            }

            setPill('saving','저장중');

            const ok = await postPatchEvent(it.id, {
              date_start: cur.date_start,
              date_end: cur.date_end,
              title: cur.title,
              content_raw: cur.content_raw,
              image_url: cur.image_url,
              hidden: cur.hidden ? 'TRUE' : 'FALSE'
            });
            if (!ok) throw new Error('SAVE_FAILED');

            if (uiTitle) uiTitle.textContent = cur.title;

            const party = String(it.party || '').trim();
            const meta = `${cur.date_start || ''}${party ? ' · ' + party : ''} · ${it.id}`;
            if (uiMeta) uiMeta.textContent = meta;

            if (uiBody) uiBody.innerHTML = buildPreview(cur.content_raw || '');

            applyHiddenUi(!!cur.hidden);
            originalHidden = !!cur.hidden;

            original = cur;
            openEditor(false);
            setPill('saved','저장됨');
          }catch(e){
            setPill('err','오류');
            alert('저장 실패: ' + (e && e.message ? e.message : String(e)));
          }
        });
      }

      const getTags = () => parseTagsToArray(root.querySelector('[data-role="tags-raw"]').value);
      const setTags = (arr) => {
        const norm = normalizeTagsArray(arr);
        root.querySelector('[data-role="tags-raw"]').value = norm.join(',');
        scheduleSave(it.id, norm, pill);
      };

      root.querySelectorAll('input[type="checkbox"][data-tg]').forEach(chk=>{
        chk.addEventListener('change', ()=>{
          const kind = chk.dataset.tg;
          const key = chk.dataset.key;
          const checked = chk.checked;

          let tags = getTags();

          if (kind === 'base'){
            if (key === '보수' && checked) tags = removeDbBase(tags, '진보');
            if (key === '진보' && checked) tags = removeDbBase(tags, '보수');

            tags = checked ? addDbBase(tags, key) : removeDbBase(tags, key);
            setTags(tags);
            return;
          }

          if (kind === 'typed'){
            if (checked){
              tags = upsertTyped(tags, key, getTypedTagValue(tags, key) || '');
              showNote(root, key, true);
              focusNote(root, key);
            }else{
              tags = removeTyped(tags, key);
              showNote(root, key, false);
              clearNote(root, key);
            }
            setTags(tags);
            return;
          }
        });
      });

      ['economy','important','mourning'].forEach(tp=>{
        const input = root.querySelector(`.tag-note[data-note="${tp}"] input`);
        if (!input) return;

        let t = null;
        input.addEventListener('input', ()=>{
          clearTimeout(t);
          t = setTimeout(()=>{
            let tags = getTags();
            const on = root.querySelector(`input[type="checkbox"][data-tg="typed"][data-key="${tp}"]`)?.checked;
            if (!on) return;
            tags = upsertTyped(tags, tp, input.value || '');
            setTags(tags);
          }, 450);
        });

        input.addEventListener('blur', ()=>{
          let tags = getTags();
          const on = root.querySelector(`input[type="checkbox"][data-tg="typed"][data-key="${tp}"]`)?.checked;
          if (!on) return;
          tags = upsertTyped(tags, tp, input.value || '');
          setTags(tags);
        });
      });

      const groupBox = root.querySelector('.group-editor[data-tg="group"]');
      if (groupBox){
        const input = groupBox.querySelector('input[data-role="group-input"]');
        const btnApply = groupBox.querySelector('[data-action="group-apply"]');
        const btnClear = groupBox.querySelector('[data-action="group-clear"]');

        const applyGroup = (raw) => {
          const v = String(raw || '').trim();
          if (v && !GROUP_RE.test(v)){
            alert('형식이 올바르지 않습니다.\nE-xxxxxx-xx (예: E-202601-01)');
            return;
          }
          let tags = getTags();
          tags = removeGroupTags(tags);
          if (v) tags = tags.concat([v]);
          setTags(tags);
          if (input) input.value = v;
        };

        if (btnApply) btnApply.addEventListener('click', ()=> applyGroup(input ? input.value : ''));
        if (btnClear) btnClear.addEventListener('click', ()=> applyGroup(''));

        if (input){
          input.addEventListener('keydown', (e)=>{
            if (e.key === 'Enter'){
              e.preventDefault();
              applyGroup(input.value);
            }
          });
        }
      }
    }

    async function safeReadJson_(res){
      const text = await res.text();
      if (text && /<!doctype html|<html/i.test(text)) {
        throw new Error("API가 JSON 대신 HTML을 반환했습니다. (웹앱 배포/권한/URL 확인 필요)");
      }
      try{
        return JSON.parse(text);
      }catch(_){
        throw new Error("JSON 파싱 실패: " + (text ? text.slice(0, 140) : "(empty)"));
      }
    }

  /* =========================
     새 이벤트 추가 탭 (단건/일괄)
  ========================= */
  const add = {
    line: document.getElementById('addLine'),
    save: document.getElementById('addSave'),
    clear: document.getElementById('addClear'),
    status: document.getElementById('addStatus'),
    preview: document.getElementById('addPreview')
  };
  
  const ADD_COLS = ["id","date_type","date_start","date_end","title","content_raw","party","is_foreign","country","tags","created_at"];
  
  function splitNonEmptyLines_(text){
    return String(text || "").replace(/\r/g,"").split("\n").map(s=>s.trim()).filter(Boolean);
  }
  
  function parsePipeLineStrict_(line){
    const raw = String(line || '').replace(/\r/g,'').trim();
    if (!raw) return null;
  
    const parts = raw.split('|');
  
    // 11칸 미만이면 패딩, 초과면 오류(파이프가 본문에 섞인 경우)
    if (parts.length < 11) {
      while(parts.length < 11) parts.push('');
    } else if (parts.length > 11) {
      throw new Error('열 개수 초과(11칸 필요). content_raw에 | 가 포함되었는지 확인하세요.');
    }
  
    const obj = {};
    for (let i=0;i<11;i++){
      obj[ADD_COLS[i]] = (parts[i] ?? '').toString();
    }
    return obj;
  }
  
  function validateAddObj_(obj){
    const ds = String(obj?.date_start || '').trim();
    const de = String(obj?.date_end || '').trim();
    const title = String(obj?.title || '').trim();
  
    if (!ds && de) return 'date_end를 쓰려면 date_start가 필요합니다.';
    if (!ds) return 'date_start는 필수입니다.';
    if (!title) return 'title은 필수입니다.';
    return '';
  }
  
  function renderAddPreviewFromText_(){
    const lines = splitNonEmptyLines_(add.line.value);
  
    if (!lines.length){
      add.preview.textContent = '(아직 없음)';
      add.status.textContent = '';
      return;
    }
  
    // 단건이면 기존처럼 자세히 보여주고,
    // 여러 건이면 라인별 요약/오류를 보여줌
    if (lines.length === 1){
      try{
        const obj = parsePipeLineStrict_(lines[0]);
        const err = validateAddObj_(obj);
        if (err) throw new Error(err);
  
        add.preview.textContent = ADD_COLS.map(k => `${k}: ${obj[k] ?? ''}`).join('\n');
        add.status.textContent = '';
      }catch(e){
        add.preview.textContent = '미리보기 오류: ' + (e?.message ? e.message : String(e));
      }
      return;
    }
  
    const out = [];
    out.push(`총 ${lines.length}행 (1행=1이벤트)`);
    out.push('---');
  
    let okCount = 0;
    lines.forEach((line, idx) => {
      try{
        const obj = parsePipeLineStrict_(line);
        const err = validateAddObj_(obj);
        if (err) throw new Error(err);
  
        okCount++;
        const range = (obj.date_end && String(obj.date_end).trim()) ? ` ~ ${obj.date_end}` : '';
        out.push(`[${idx+1}] ✅ ${obj.date_start}${range} | ${obj.title} | tags=${obj.tags || ''}`);
      }catch(e){
        out.push(`[${idx+1}] ❌ ${e?.message ? e.message : String(e)}`);
      }
    });
  
    out.push('---');
    out.push(`검증 통과: ${okCount}/${lines.length}`);
    add.preview.textContent = out.join('\n');
  }
  
  add.line.addEventListener('input', renderAddPreviewFromText_);
  
  add.clear.addEventListener('click', ()=>{
    add.line.value = '';
    add.preview.textContent = '(아직 없음)';
    add.status.textContent = '';
  });
  
  /** ✅ 단건: appendEvent(form)
   *  ✅ 일괄: appendEvents(JSON)
   *
   *  ⚠️ 주의: Google Apps Script WebApp은 CORS preflight(OPTIONS)를 처리하지 못하는 경우가 많아서
   *  `Content-Type: application/json` 같은 헤더를 붙이면 브라우저에서 "Failed to fetch"가 날 수 있습니다.
   *  그래서 headers를 지정하지 않고 JSON 문자열을 body로만 보내 preflight를 피합니다.
   */
  async function postAppendEvents_(lines){
    const params = new URLSearchParams();
    params.set('mode','appendEvents');
    if (TG_ADMIN_KEY) params.set('key', TG_ADMIN_KEY);
    const url = `${API_BASE}?${params.toString()}`;

    try{
      const res = await fetch(url, {
        method: 'POST',
        // ✅ headers 금지(=preflight 방지)
        body: JSON.stringify({ lines }),
        cache: 'no-store',
        credentials: 'omit'
      });

      const text = await res.text();
      let data = null;
      try { data = JSON.parse(text); } catch(_){ }

      if (!res.ok) return { ok:false, error:`HTTP ${res.status}: ${text.slice(0,300)}` };
      if (!data)   return { ok:false, error:`JSON 아님: ${text.slice(0,300)}` };
      return { ok:true, data };
    }catch(e){
      return { ok:false, error: e && e.message ? e.message : String(e) };
    }
  }

  function replaceIdInLine_(line, newId){
    const parts = String(line || '').split('|');
    while(parts.length < 11) parts.push('');
    parts[0] = String(newId || '').trim();
    return parts.slice(0,11).join('|');
  }

  add.save.addEventListener('click', async ()=>{
    try{
      const lines = splitNonEmptyLines_(add.line.value);
      if (!lines.length) { alert('입력 라인이 비어있습니다.'); return; }

      // ✅ 일괄 저장(배치) + 결과 id를 입력값에 되돌려쓰기
      const BATCH = 200; // 너무 크면 실패할 수 있어 적당히 쪼갭니다.
      const allResults = [];

      add.status.textContent = `일괄 저장 중... (0/${lines.length})`;

      for (let s=0; s<lines.length; s+=BATCH){
        const chunk = lines.slice(s, s+BATCH);
        add.status.textContent = `일괄 저장 중... (${Math.min(s+BATCH, lines.length)}/${lines.length})`;

        const r = await postAppendEvents_(chunk);
        if (!r.ok) throw new Error(r.error || 'BULK_SAVE_FAILED');

        const results = Array.isArray(r.data && r.data.results) ? r.data.results : [];
        if (!results.length) throw new Error('서버 응답에 results가 없습니다. (appendEvents)');

        allResults.push(...results);

        // 일부 실패가 있으면 여기서 멈춤(중복 저장 방지). 원하면 계속 진행으로 바꿀 수 있음
        const okThisBatch = results.every(x => x && x.ok === true);
        if (!okThisBatch) break;
      }

      // 결과 반영
      const newLines = lines.map((line, i)=>{
        const rr = allResults[i];
        if (rr && rr.ok === true && rr.id) return replaceIdInLine_(line, rr.id);
        return line;
      });
      add.line.value = newLines.join('\n');

      const okCount = allResults.filter(x => x && x.ok === true).length;
      const failIdx = [];
      allResults.forEach((x, i)=>{ if (!x || x.ok !== true) failIdx.push(i+1); });
      // 처리되지 않은 행(서버 중단/부분 실행)도 실패로 표시
      for (let i=allResults.length; i<lines.length; i++){ failIdx.push(i+1); }

      renderAddPreviewFromText_();

      if (failIdx.length){
        add.status.textContent = `부분 실패: 성공 ${okCount}/${lines.length} (실패 행: ${failIdx.join(', ')})`;
        alert(`일괄 저장 중 일부 실패가 있습니다.\n실패 행: ${failIdx.join(', ')}\n미리보기에서 오류를 확인하세요.`);
        return;
      }

      add.status.textContent = `일괄 저장 완료: ${okCount}/${lines.length}`;
    }catch(e){
      add.status.textContent = '';
      renderAddPreviewFromText_();
      alert('저장 실패: ' + (e && e.message ? e.message : String(e)));
    }
  });

// 초기 1회
  renderAddPreviewFromText_();

  // ✅ Clipboard 이미지 Blob -> base64(데이터 부분만)
  function readBlobAsBase64_(blob){
    return new Promise((resolve, reject) => {
      try{
        const fr = new FileReader();
        fr.onload = () => {
          const s = String(fr.result || "");
          const i = s.indexOf(",");
          resolve(i >= 0 ? s.slice(i + 1) : s); // "data:...;base64," 헤더 제거
        };
        fr.onerror = () => reject(fr.error || new Error("FileReader failed"));
        fr.readAsDataURL(blob);
      }catch(e){
        reject(e);
      }
    });
  }
    function extractImportantLabelsFromTags_(tagsStr){
  const tags = String(tagsStr || "")
    .split(",")
    .map(s => String(s).trim())
    .filter(Boolean);

  const out = [];
  tags.forEach(t => {
    // important 또는 important-라벨
    const m = /^important(?:-(.+))?$/i.exec(t);
    if (!m) return;

    const label = String(m[1] || "").trim();
    // 라벨 없는 "important"는 추천 키워드로 의미가 약해서 제외(원하면 포함으로 바꿔도 됨)
    if (!label) return;

    out.push(label);
  });
  return out;
}

function buildListUrlForSuggest_(){
  // Export 탭과 동일한 필터 입력값 사용
  const year  = String(el.year.value || "").trim();
  const month = String(el.month.value || "").trim();
  const day   = String(el.day.value || "").trim();
  const start = String(el.start.value || "").trim();
  const end   = String(el.end.value || "").trim();
  const ids   = String(el.ids.value || "").trim();

  if (!day && !start && !end && (!year || !month)) {
    throw new Error("월 추천은 연도/월이 필요합니다. (또는 기간 start/end, 일 day)");
  }

  const params = new URLSearchParams();
  params.set("mode", "listEvents");
  params.set("limit", "800");

  if (day) {
    params.set("day", day);
  } else if (start || end) {
    if (start) params.set("start", start);
    if (end) params.set("end", end);
  } else {
    params.set("year", year);
    params.set("month", month);
  }

  // ✅ 추천은 숨김(비표시) 제외가 자연스러움
  params.set("includeHidden", "false");

  if (ids) params.set("id", ids);
  if (TG_ADMIN_KEY) params.set("key", TG_ADMIN_KEY);

  return `${API_BASE}?${params.toString()}`;
}

async function autoSuggestMonthNote_(){
  const topN = Math.min(Math.max(Number(mn.topN?.value || 8), 3), 20);

  const url = buildListUrlForSuggest_();
  const res = await fetch(url, { method:"GET", cache:"no-store", credentials:"omit" });
  if (!res.ok) throw new Error("추천용 목록 API 실패 (HTTP " + res.status + ")");

  const data = await safeReadJson_(res);
  if (!data || data.ok !== true) throw new Error((data && data.error) ? data.error : "UNKNOWN_ERROR");

  const items = Array.isArray(data.items) ? data.items : [];
  const freq = new Map();

  items.forEach(it => {
    const labels = extractImportantLabelsFromTags_(it.tags || "");
    labels.forEach(lb => freq.set(lb, (freq.get(lb) || 0) + 1));
  });

  const ranked = Array.from(freq.entries())
    .sort((a,b) => (b[1] - a[1]) || String(a[0]).localeCompare(String(b[0]), "ko"));

  const picked = ranked.slice(0, topN).map(x => x[0]);

  // 타이틀 자동
  const y = String(el.year.value || "").trim();
  const m = String(el.month.value || "").trim();
  if (y && m && !el.day.value && !el.start.value && !el.end.value) {
    mn.title.value = `${y}년 ${m}월 핵심 키워드`;
  } else {
    mn.title.value = `범위 핵심 키워드`;
  }

  mn.tags.value = picked.join("\n");
  mn.desc.value = `※ important 태그 중복 빈도 Top ${picked.length} 기준 추천`;

  buildMonthNote();
  saveMonthNote();
}
그리고 버튼 클릭 바인딩 추가:

if (mn.auto){
  mn.auto.addEventListener("click", async (e)=>{
    e.preventDefault();
    try{
      await autoSuggestMonthNote_();
      alert("important 태그 추천을 반영했습니다. (필요하면 키워드를 직접 수정하세요)");
    }catch(err){
      alert("자동 추천 실패: " + (err && err.message ? err.message : String(err)));
    }
  });
}
</script>
</body>
</html>
