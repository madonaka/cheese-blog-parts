<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>포스트 관리</title>

  <!-- ✅ 메인 관리자 CSS 재사용 -->
  <link rel="stylesheet" href="./admin.css" />

  <style>
    /* ===== page local styles ===== */
    .pm-wrap{ padding: 14px; }

    .pm-card{
      background:#fff;
      border:1px solid rgba(15,23,42,0.14);
      border-radius:14px;
      padding:14px;
      margin-bottom:12px;
      box-shadow:0 10px 24px rgba(15,23,42,0.06);
    }

    .pm-row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .pm-label{ font-weight:800; }

    .pm-input, .pm-select{
      padding:10px 12px;
      border:1px solid rgba(15,23,42,0.2);
      border-radius:10px;
      min-width:280px;
      background:#fff;
    }

    .pm-title{ min-width:420px; }

    .pm-textarea{
      width:100%;
      min-height:420px;
      padding:12px;
      border:1px solid rgba(15,23,42,0.2);
      border-radius:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size:13px;
      line-height:1.45;
    }

    .pm-btn{
      padding:10px 12px;
      border-radius:10px;
      border:1px solid rgba(15,23,42,0.18);
      background:#fff;
      cursor:pointer;
      font-weight:800;
      white-space:nowrap;
    }

    .pm-btn.primary{ background:#111827; color:#fff; border-color:#111827; }
    .pm-btn.danger{ background:#b91c1c; color:#fff; border-color:#b91c1c; }
    .pm-btn.ghost{ background:rgba(15,23,42,0.03); }
    .pm-btn.small{ padding:8px 10px; font-size:12px; border-radius:9px; }

    .pm-muted{ color:#6b7280; font-size:13px; }
    .pm-status{ margin-top:10px; font-size:13px; }
    .pm-status.ok{ color:#047857; }
    .pm-status.err{ color:#b91c1c; }

    .pm-meta{ display:grid; grid-template-columns: 140px 1fr; gap:8px 12px; margin-top:10px; }
    .pm-meta div{ padding:6px 0; }

    .pm-link{ color:#2563eb; font-weight:800; text-decoration:none; }

    .pm-pill{
      display:inline-block;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(15,23,42,0.15);
      font-size:12px;
      margin-left:8px;
    }

    .pm-small{ font-size:12px; color:#6b7280; }

    .pm-banner{
      margin: 0 0 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(185,28,28,0.25);
      background: rgba(185,28,28,0.06);
      color:#7f1d1d;
      font-weight:800;
      font-size:13px;
      display:none;
      white-space:pre-line;
    }

    /* ===== dynamic fields ===== */
    .pm-dyn-grid{
      display:grid;
      grid-template-columns: 120px 1fr;
      gap:10px 12px;
      align-items:start;
    }
    @media (max-width: 980px){
      .pm-dyn-grid{ grid-template-columns: 1fr; }
    }
    .pm-dyn-item{
      border:1px solid rgba(15,23,42,0.12);
      border-radius:12px;
      padding:10px;
      background:rgba(15,23,42,0.02);
    }
    .pm-dyn-key{ font-weight:900; margin:0 0 6px; }
    .pm-dyn-help{ margin:0 0 10px; }
    .pm-dyn-textarea{ min-height:200px; }
    .pm-hr{ height:1px; background:rgba(15,23,42,0.10); margin:12px 0; }

    .pm-hidden{ display:none !important; }

    /* ==============================
       ✅ Sticky Action Bar (NEW)
    ============================== */
    .pm-stickybar{
      position: sticky;
      top: 0;
      z-index: 50;
      margin: 0 0 12px;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(15,23,42,0.14);
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 24px rgba(15,23,42,0.08);
    }
    .pm-stickybar .bar-row{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .pm-stickybar .bar-left{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .pm-stickybar .bar-right{
      margin-left:auto;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .pm-sticky-id{
      font-weight:900;
      padding:6px 10px;
      border-radius:999px;
      background:rgba(15,23,42,0.04);
      border:1px solid rgba(15,23,42,0.12);
      max-width:340px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .pm-sticky-status{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(15,23,42,0.12);
      background:rgba(15,23,42,0.03);
      font-size:12px;
      color:#111827;
      max-width:520px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .pm-sticky-status.ok{ color:#047857; border-color: rgba(4,120,87,0.25); background: rgba(4,120,87,0.06); }
    .pm-sticky-status.err{ color:#b91c1c; border-color: rgba(185,28,28,0.25); background: rgba(185,28,28,0.06); }

    .pm-spinner{
      width:14px;
      height:14px;
      border-radius:50%;
      border:2px solid rgba(15,23,42,0.22);
      border-top-color: rgba(15,23,42,0.75);
      animation: pmspin 0.9s linear infinite;
      display:none;
      flex:0 0 auto;
    }
    .pm-spinner.on{ display:inline-block; }
    @keyframes pmspin { to { transform: rotate(360deg); } }

    .pm-sticky-actions{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .pm-divider{
      width:1px;
      height:26px;
      background:rgba(15,23,42,0.12);
      margin:0 2px;
    }
  </style>
</head>

<body>
  <div class="admin-shell">
    <div id="admin-header-slot"></div>

    <div class="admin-main">
      <aside id="admin-menu-slot" class="admin-sidebar"></aside>

      <main class="admin-content">
        <div class="pm-wrap">
          <h2 style="margin:0 0 12px;">
            포스트 관리 <span class="pm-pill">Sheet DB + Drive HTML</span>
          </h2>

          <div id="banner" class="pm-banner"></div>

          <!-- ==============================
               ✅ Sticky Action Bar (NEW)
               - 항상 상단에 고정
               - 핵심 액션 + 진행상태 표시
          ============================== -->
          <div class="pm-stickybar" id="stickyBar">
            <div class="bar-row">
              <div class="bar-left">
                <div class="pm-sticky-id" id="stickyId">ID: -</div>

                <div class="pm-sticky-status" id="stickyStatus">
                  <span class="pm-spinner" id="stickySpinner"></span>
                  <span id="stickyStatusText">준비됨</span>
                </div>
              </div>

              <div class="bar-right">
                <div class="pm-sticky-actions">
                  <!-- 원클릭 파이프라인 -->
                  <button id="btnQuickPublish" class="pm-btn primary">원클릭 발행</button>
                  <button id="btnQuickDraft" class="pm-btn ghost">원클릭 초안 저장</button>

                  <div class="pm-divider"></div>

                  <!-- 자주 쓰는 단일 액션 -->
                  <button id="btnQuickDriveSave" class="pm-btn">Drive 저장</button>
                  <button id="btnQuickBloggerUpsert" class="pm-btn">Blogger 업로드</button>

                  <div class="pm-divider"></div>

                  <button id="btnQuickBloggerRead" class="pm-btn small">Blogger 불러오기</button>
                  <button id="btnQuickLabels" class="pm-btn small">라벨 적용</button>

                  <a id="stickyOpenBlogger" class="pm-link" href="#" target="_blank" style="display:none;">글 열기</a>
                </div>
              </div>
            </div>

            <div class="bar-row" style="margin-top:10px;">
              <div class="pm-row" style="width:100%;">
                <div class="pm-label">라벨</div>
                <input
                  id="bloggerLabelsTop"
                  class="pm-input"
                  type="text"
                  placeholder="예: 주요 사건,2026,정치 (콤마로 구분)"
                  style="min-width:320px;"
                />
                <select id="bloggerLabelsActionTop" class="pm-select" style="min-width:160px;">
                  <option value="replace">덮어쓰기</option>
                  <option value="add">추가</option>
                  <option value="remove">제거</option>
                </select>
                <span class="pm-muted pm-small" id="stickyLabelsHint">※ 입력이 비어 있으면 업로드 시 기존 라벨 유지(keep)</span>
              </div>
            </div>
          </div>

          <section class="pm-card">
            <div class="pm-row">
              <div class="pm-label">Post 선택</div>
              <select id="postSelect" class="pm-select"></select>

              <button id="btnRefresh" class="pm-btn">목록 새로고침</button>
              <button id="btnLoad" class="pm-btn primary">불러오기</button>
            </div>

            <div class="pm-row" style="margin-top:10px;">
              <div class="pm-label">ID</div>
              <input id="id" class="pm-input" type="text" placeholder="예: NM_20260121_01" disabled />
              <button id="btnSetFromSelect" class="pm-btn">선택값을 ID에 반영</button>
            </div>

            <div class="pm-row" style="margin-top:10px;">
              <div class="pm-label">분류</div>
              <select id="category" class="pm-select">
                <option value="">분류 선택...</option>
                <option value="monthly_news">주요 사건, 이슈, 뉴스 월별 총정리</option>
                <option value="timeline_kr_cn_jp">한국사+중국사+일본사 연표</option>
                <option value="genealogy_series">가계도시리즈</option>
                <option value="etc">기타</option>
                <option value="manual">수동입력</option>
              </select>
              <button id="btnRegenId" class="pm-btn">ID 새로 생성</button>
              <div class="pm-muted pm-small">※ 분류 선택 시 ID 자동생성. “수동입력”만 직접 입력 가능.</div>
            </div>

            <div class="pm-row" style="margin-top:10px;">
              <div class="pm-label">템플릿(Drive)</div>
              <select id="templateSelect" class="pm-select" style="min-width:280px;"></select>

              <button id="btnApplyTemplate" class="pm-btn">템플릿 적용(새로)</button>
              <button id="btnRewrapTemplate" class="pm-btn">래퍼 재적용(본문 유지)</button>

              <span class="pm-muted pm-small">
                ※ 템플릿은 Drive의 매니페스트(JSON) + 섹션(HTML 조각)을 조립합니다.
              </span>
            </div>

            <div id="status" class="pm-status pm-muted">준비됨</div>

            <details style="margin-top:10px;">
              <summary class="pm-muted" style="cursor:pointer; font-weight:800;">디버그(마지막 응답)</summary>
              <pre id="debug" style="margin:10px 0 0; padding:10px; border:1px solid rgba(15,23,42,0.14); border-radius:12px; background:rgba(15,23,42,0.03); overflow:auto; max-height:220px; font-size:12px;"></pre>
            </details>

            <div class="pm-meta">
              <div class="pm-muted">Drive fileId</div><div id="driveFileId" class="pm-muted">-</div>
              <div class="pm-muted">Drive url</div><div id="driveUrl" class="pm-muted">-</div>
              <div class="pm-muted">Updated</div><div id="updatedAt" class="pm-muted">-</div>
            </div>

            <div class="pm-row" style="margin-top:10px;">
              <a id="openDriveLink" class="pm-link" href="#" target="_blank" style="display:none;">Drive 파일 열기</a>
            </div>
          </section>

          <section class="pm-card">
            <div class="pm-row">
              <div class="pm-label">Title</div>
              <input id="title" class="pm-input pm-title" type="text" placeholder="글 제목" />
              <div class="pm-muted" id="charCount">0 chars</div>
            </div>

            <div style="margin-top:10px;">
              <div class="pm-label" style="margin-bottom:6px;">HTML(최종본)</div>
              <textarea id="html" class="pm-textarea" placeholder="여기에 최종 HTML이 생성됩니다. (디버그/직접편집 가능)"></textarea>
            </div>

            <div style="margin-top:10px;">
              <div class="pm-label" style="margin-bottom:6px;">동적 입력(템플릿 슬롯/토큰)</div>
              <p class="pm-muted pm-small pm-dyn-help" id="dynHelp">
                ※ 템플릿에서 SLOT(예: BODY_1/2/3) 또는 토큰(예: {{THUMB_URL}})을 감지해 입력칸이 자동 생성됩니다.
              </p>

              <!-- SLOT(TEXTAREA) -->
              <div id="slotFields" class="pm-dyn-grid"></div>

              <div class="pm-hr"></div>

              <!-- Token(INPUT) -->
              <div id="tokenFields" class="pm-dyn-grid"></div>
            </div>

            <!-- 기존 하단 버튼(유지) -->
            <div class="pm-row" style="margin-top:12px;">
              <button id="btnDriveUpsert" class="pm-btn">Drive로 저장/업데이트</button>
              <button id="btnDriveRead" class="pm-btn">Drive에서 불러오기</button>
              <button id="btnClear" class="pm-btn danger">편집창 비우기</button>
            </div>

            <div class="pm-row" style="margin-top:12px;">
              <div class="pm-label">Blogger</div>
              <label class="pm-muted" style="display:flex; gap:6px; align-items:center;">
                <input id="bloggerPublish" type="checkbox" />
                발행(publish)
              </label>
              <button id="btnBloggerUpsert" class="pm-btn">블로그 업로드/수정</button>
              <button id="btnBloggerRead" class="pm-btn">블로그에서 불러오기</button>
              <a id="openBloggerLink" class="pm-link" href="#" target="_blank" style="display:none;">Blogger 글 열기</a>
              <span id="bloggerMeta" class="pm-muted pm-small"></span>
            </div>

            <div class="pm-row" style="margin-top:10px;">
              <div class="pm-label">라벨</div>

              <input
                id="bloggerLabels"
                class="pm-input"
                type="text"
                placeholder="예: 주요 사건,2026,정치 (콤마로 구분)"
              />

              <select id="bloggerLabelsAction" class="pm-select" style="min-width:180px;">
                <option value="replace">덮어쓰기</option>
                <option value="add">추가</option>
                <option value="remove">제거</option>
              </select>

              <button id="btnBloggerLabels" class="pm-btn">라벨 적용</button>

              <button id="btnBloggerRevert" class="pm-btn danger">초안으로 되돌리기</button>

              <span class="pm-muted pm-small">※ “초안으로 되돌리기”는 발행/예약 글을 draft로 되돌립니다.</span>
              <div class="pm-muted pm-small" id="currentLabelsView" style="margin-left:140px;">
                현재 라벨: -
              </div>
            </div>
          </section>
        </div>
      </main>
    </div>
  </div>

  <!-- ✅ 반드시 포함해야 하는 공통 스크립트 유지 -->
  <script src="./admin-common.js"></script>

  <script>
  /** =========================
   * ✅ admin-common.js: 헤더/메뉴 슬롯 유지
   * ========================= */
  (function renderShellOnce(){
    try{
      if (window.AdminCommon && typeof window.AdminCommon.renderShell === "function"){
        window.AdminCommon.renderShell({
          headerSlotId: "admin-header-slot",
          menuSlotId: "admin-menu-slot",
          activeMenu: "post_manage"
        });
      }
    }catch(_){}
  })();

  (() => {
    const $ = (id) => document.getElementById(id);
    let current = null;

    // ✅ 고정: Apps Script 주소
    const API_BASE =
      "https://script.google.com/macros/s/AKfycbzj5LUEUKMyQqJfVsVlftO1f4CTYb3NhAQMT2QL6VADBlnjleAXLtBVVhuVHOfwkhQYqQ/exec";

    // 섹션 HTML 캐시(같은 섹션을 여러 번 조립할 때 API 호출 최소화)
    const sectionCache = new Map(); // key: sectionName, value: html

    // 현재 템플릿 분석 결과
    const templateState = {
      templateId: "",
      manifest: null,
      slots: [],   // ["BODY_1", "BODY_2", ...]
      tokens: []   // ["THUMB_URL", "CANONICAL_URL", ...]
    };

    /* =========================
       ✅ Sticky bar helpers (NEW)
    ========================= */
    function setBusy_(on){
      const sp = $("stickySpinner");
      if (!sp) return;
      sp.classList.toggle("on", !!on);
    }

    function setStickyId_(){
      const id = getTargetId() || "-";
      $("stickyId").textContent = "ID: " + id;
    }

    function syncTopLabelControls_(){
      // 상단 ↔ 하단 라벨 입력을 한쪽만 써도 되게 “동기화”
      const topL = $("bloggerLabelsTop");
      const botL = $("bloggerLabels");
      const topA = $("bloggerLabelsActionTop");
      const botA = $("bloggerLabelsAction");

      if (topL && botL && topL.value.trim() && !botL.value.trim()) botL.value = topL.value;
      if (topL && botL && botL.value.trim() && !topL.value.trim()) topL.value = botL.value;

      if (topA && botA){
        if (topA.value && !botA.value) botA.value = topA.value;
        if (botA.value && !topA.value) topA.value = botA.value;
      }
    }

    // 상단/하단 라벨 입력은 서로 실시간 동기화
    ["bloggerLabelsTop","bloggerLabels"].forEach(id=>{
      const el = $(id);
      if (el) el.addEventListener("input", ()=>{
        const a = $("bloggerLabelsTop"), b = $("bloggerLabels");
        if (!a || !b) return;
        if (id === "bloggerLabelsTop") b.value = a.value;
        else a.value = b.value;
      });
    });
    ["bloggerLabelsActionTop","bloggerLabelsAction"].forEach(id=>{
      const el = $(id);
      if (el) el.addEventListener("change", ()=>{
        const a = $("bloggerLabelsActionTop"), b = $("bloggerLabelsAction");
        if (!a || !b) return;
        if (id === "bloggerLabelsActionTop") b.value = a.value;
        else a.value = b.value;
      });
    });

    /* =========================
       ✅ 실시간 프리뷰(동적 슬롯/토큰 입력 → 최종 HTML 자동 조립)
    ========================= */
    let previewTimer = null;
    let previewSeq = 0;

    function scheduleAssemblePreview_(){
      clearTimeout(previewTimer);
      previewTimer = setTimeout(runAssemblePreview_, 250);
    }

    async function runAssemblePreview_(){
      const tplId = $("templateSelect") ? $("templateSelect").value : "";
      if (!tplId) return;

      const seq = ++previewSeq;
      try{
        const out = await assembleHtmlUsingState_(tplId, buildVarsForAssemble_());
        if (seq !== previewSeq) return;

        $("html").value = out.html;
        syncCharCount();
      }catch(e){
        setStatus("프리뷰 조립 실패: " + (e?.message || e), false);
        setDebug(String(e && e.stack ? e.stack : e));
      }
    }

    // ✅ 이벤트 위임 방식: 동적 필드가 재렌더링되어도 항상 input/change가 잡힘
    (function bindPreviewDelegation_(){
      const bind = (boxId) => {
        const box = $(boxId);
        if (!box || box.__pmDelegationBound) return;
        box.addEventListener("input", scheduleAssemblePreview_, true);
        box.addEventListener("change", scheduleAssemblePreview_, true);
        box.__pmDelegationBound = true;
      };
      bind("slotFields");
      bind("tokenFields");
    })();

    function attachDynamicPreviewListeners_(){
      document.querySelectorAll("[data-slot]").forEach(el=>{
        if (el.__pmPreviewBound) return;
        el.addEventListener("input", scheduleAssemblePreview_);
        el.addEventListener("change", scheduleAssemblePreview_);
        el.__pmPreviewBound = true;
      });

      document.querySelectorAll("[data-token]").forEach(el=>{
        if (el.__pmPreviewBound) return;
        el.addEventListener("input", scheduleAssemblePreview_);
        el.addEventListener("change", scheduleAssemblePreview_);
        el.__pmPreviewBound = true;
      });
    }

    function setStatus(msg, ok=true){
      // 기존 하단 status
      const el = $("status");
      el.textContent = msg;
      el.className = "pm-status " + (ok ? "ok" : "err");

      // ✅ Sticky bar status도 같이 갱신
      const st = $("stickyStatus");
      const tx = $("stickyStatusText");
      if (tx) tx.textContent = msg;
      if (st){
        st.classList.remove("ok","err");
        st.classList.add(ok ? "ok" : "err");
      }
    }

    function showBanner(msg){
      const b = $("banner");
      b.textContent = msg;
      b.style.display = "block";
    }

    function hideBanner(){
      const b = $("banner");
      b.textContent = "";
      b.style.display = "none";
    }

    function setDebug(obj){
      const el = $("debug");
      if (!el) return;
      try{ el.textContent = (typeof obj === 'string') ? obj : JSON.stringify(obj, null, 2); }
      catch(e){ el.textContent = String(obj); }
    }

    function setMeta(post){
      $("driveFileId").textContent = post.drive_file_id || "-";
      $("driveUrl").textContent = post.drive_url || "-";
      $("updatedAt").textContent = post.updated_at || "-";

      const link = $("openDriveLink");
      if (post.drive_url){
        link.href = post.drive_url;
        link.style.display = "inline";
      } else {
        link.style.display = "none";
      }
    }

    function setBloggerMeta(info){
      const meta = $("bloggerMeta");
      const link = $("openBloggerLink");
      const stickyLink = $("stickyOpenBlogger");

      if (meta){
        meta.textContent = info
          ? (info.status ? `status: ${info.status}` : '') + (info.post_id ? `  postId: ${info.post_id}` : '')
          : '';
      }

      if (link){
        if (info && info.url){
          link.href = info.url;
          link.style.display = 'inline';
        }else{
          link.style.display = 'none';
        }
      }

      // ✅ sticky link도 같이 세팅
      if (stickyLink){
        if (info && info.url){
          stickyLink.href = info.url;
          stickyLink.style.display = 'inline';
        }else{
          stickyLink.style.display = 'none';
        }
      }
    }

    function syncCharCount(){
      $("charCount").textContent = ($("html").value || "").length + " chars";
    }
    $("html").addEventListener("input", syncCharCount);
    $("title").addEventListener("input", ()=>{ attachDynamicPreviewListeners_(); scheduleAssemblePreview_(); });

    function buildUrl(mode, paramsObj){
      const params = new URLSearchParams();
      params.set("mode", mode);
      params.set("_ts", String(Date.now()));

      if (paramsObj && typeof paramsObj === "object"){
        for (const [k,v] of Object.entries(paramsObj)){
          if (v === undefined || v === null) continue;
          params.set(k, String(v));
        }
      }
      return `${API_BASE}?${params.toString()}`;
    }

    // ===== meta/body parsing (기존 글 수정용) =====
    function readTemplateMeta_(html){
      const get = (key) => {
        const re = new RegExp(`<!--\\s*${key}\\s*:\\s*([^>]+?)\\s*-->`, "i");
        const m = String(html||"").match(re);
        return m ? m[1].trim() : "";
      };
      return {
        template_id: get("template_id"),
        template_ver: get("template_ver"),
      };
    }

    // ✅ 다중 BODY 마커도 지원
    function extractBodies_(html){
      const t = String(html || "");
      const out = {};

      const reStart = /<!--\s*BODY_START(?::([A-Z0-9_]+))?\s*-->/ig;
      let m;
      while ((m = reStart.exec(t)) !== null){
        const name = (m[1] || "BODY").trim();
        const startIdx = reStart.lastIndex;

        const endMark = name === "BODY"
          ? /<!--\s*BODY_END\s*-->/ig
          : new RegExp(`<!--\\s*BODY_END\\s*:\\s*${escapeRegExp(name)}\\s*-->`, "ig");

        endMark.lastIndex = startIdx;
        const em = endMark.exec(t);
        if (!em) continue;

        const endIdx = em.index;
        out[name] = t.slice(startIdx, endIdx).trim();
        reStart.lastIndex = endMark.lastIndex;
      }

      if (Object.keys(out).length === 0){
        out["BODY"] = t.trim();
      }

      return out;
    }

    // ===== API =====
    async function apiGet(mode, paramsObj){
      const url = buildUrl(mode, paramsObj);
      const res = await fetch(url, { method:"GET", cache:"no-store", credentials:"omit" });
      const text = await res.text().catch(()=> "");
      if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}\n${text.slice(0,500)}`);
      try { return JSON.parse(text); }
      catch { throw new Error("JSON_PARSE_FAILED\n" + text.slice(0,500)); }
    }

    async function apiPost(mode, bodyObj){
      const url = `${API_BASE}?_ts=${Date.now()}`;
      const body = new URLSearchParams();
      body.set("mode", String(mode || ""));
      if (bodyObj && typeof bodyObj === "object"){
        for (const [k,v] of Object.entries(bodyObj)){
          if (v === undefined || v === null) continue;
          body.set(k, String(v));
        }
      }
      const res = await fetch(url, { method:"POST", body, cache:"no-store", credentials:"omit" });
      const text = await res.text().catch(()=> "");
      let data = null;
      try { data = JSON.parse(text); } catch(_){}
      if (!res.ok) throw new Error(`HTTP ${res.status}: ${text.slice(0,300)}`);
      if (!data)   throw new Error(`JSON 아님: ${text.slice(0,300)}`);
      return data;
    }

    // ===== 이미지 관리 (✅ JSONP로 list/get) =====
    const IMG_DB_URL =
      "https://script.google.com/macros/s/AKfycbyIsoT-0JY2nxCPFx2JH-G3Ja8tztjlJ6fiVAyxLgd-8Mzxjob8YDGgRO-biOCXe5WU/exec";

    const IMG_THUMB_W = 1200;
    function imgThumbUrl_(fileId, w = IMG_THUMB_W){
      const id = String(fileId || "").trim();
      if (!id) return "";
      return `https://drive.google.com/thumbnail?id=${encodeURIComponent(id)}&sz=w${encodeURIComponent(String(w||IMG_THUMB_W))}`;
    }

    function imgMakeNonce_(){
      return `${Date.now()}_${Math.random().toString(16).slice(2)}`;
    }

    function imgJsonpCall_(url, cbName, timeoutMs = 12000){
      return new Promise((resolve) => {
        let done = false;
        let script = null;

        const timer = setTimeout(() => {
          if (done) return;
          done = true;
          cleanup();
          resolve({ ok:false, error:"timeout" });
        }, timeoutMs);

        function cleanup(){
          clearTimeout(timer);
          try { delete window[cbName]; } catch(e){}
          if (script && script.parentNode) script.parentNode.removeChild(script);
        }

        window[cbName] = (data) => {
          if (done) return;
          done = true;
          cleanup();
          resolve(data);
        };

        script = document.createElement("script");
        script.src = url + (url.includes("?") ? "&" : "?") + `_=${Date.now()}`;
        script.onerror = () => {
          if (done) return;
          done = true;
          cleanup();
          resolve({ ok:false, error:"script_load_failed" });
        };

        document.head.appendChild(script);
      });
    }

    async function imgList_(){
      const nonce = imgMakeNonce_();
      const cb = `__img_list_cb_${nonce.replace(/[^a-zA-Z0-9_]/g,"_")}`;
      const url = `${IMG_DB_URL}?mode=list&callback=${encodeURIComponent(cb)}&nonce=${encodeURIComponent(nonce)}`;

      const res = await imgJsonpCall_(url, cb, 12000);
      if (!res || !res.ok) throw new Error(res?.error || "IMG_LIST_FAILED");
      return Array.isArray(res.items) ? res.items : [];
    }

    async function imgGet_(id){
      const nonce = imgMakeNonce_();
      const cb = `__img_get_cb_${nonce.replace(/[^a-zA-Z0-9_]/g,"_")}`;
      const url = `${IMG_DB_URL}?mode=get&id=${encodeURIComponent(String(id||""))}&callback=${encodeURIComponent(cb)}&nonce=${encodeURIComponent(nonce)}`;

      const res = await imgJsonpCall_(url, cb, 12000);
      if (!res || !res.ok) throw new Error(res?.error || "IMG_GET_FAILED");
      return res.item || null;
    }

    // ===== Drive Template/Section helpers =====
    async function listTemplates_(){
      const res = await apiGet("listTemplates");
      if (!res || !res.ok) throw new Error(res?.message || "LIST_TEMPLATES_FAILED");
      return res.items || [];
    }

    async function getTemplateManifest_(templateId){
      const res = await apiGet("getTemplate", { template_id: templateId });
      if (!res || !res.ok) throw new Error(res?.message || "GET_TEMPLATE_FAILED");

      const txt = String(res.json || "").trim();
      if (!txt) throw new Error("TEMPLATE_JSON_EMPTY");

      let manifest = null;
      try{ manifest = JSON.parse(txt); }
      catch(e){
        throw new Error("TEMPLATE_JSON_PARSE_FAILED: " + (e?.message || e));
      }
      return manifest;
    }

    async function getSectionHtml_(name){
      const key = String(name || "").trim();
      if (!key) return "";
      if (sectionCache.has(key)) return sectionCache.get(key);

      const res = await apiGet("getSection", { name: key });
      if (!res || !res.ok) throw new Error(res?.message || ("GET_SECTION_FAILED: " + key));

      const html = String(res.html || "");
      sectionCache.set(key, html);
      return html;
    }

    function buildTokensMetaComment_(vars){
      const keys = [
        "THUMB_URL","CANONICAL_URL","YEAR","MONTH",
        "YEAR_NAV_JSON",
        "IMG_ID","IMG_SRC","IMG_HREF","IMG_OW","IMG_OH",
        "IMG_ALT","IMG_TITLE","IMG_SNIPPET","ZOOM_LABEL"
      ];

      const obj = {};
      for (const k of keys){
        if (vars && vars[k] !== undefined && vars[k] !== null && String(vars[k]).trim() !== ""){
          obj[k] = String(vars[k]);
        }
      }
      if (!Object.keys(obj).length) return "";
      return `<!-- tokens: ${JSON.stringify(obj)} -->\n`;
    }

    function extractTokensMetaFromHtml_(html){
      const t = String(html || "");
      const m = t.match(/<!--\s*tokens\s*:\s*({[\s\S]*?})\s*-->/i);
      if (!m) return {};
      try{
        const obj = JSON.parse(m[1]);
        return (obj && typeof obj === "object" && !Array.isArray(obj)) ? obj : {};
      }catch(_){
        return {};
      }
    }

    function escapeRegExp(s){
      return String(s||"").replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function replaceTokens_(html, vars){
      let out = String(html || "");
      if (!vars || typeof vars !== "object") return out;

      for (const [k,v] of Object.entries(vars)){
        const key = String(k || "").trim();
        if (!key) continue;
        const re = new RegExp(`{{\\s*${escapeRegExp(key)}\\s*}}`, "g");
        out = out.replace(re, String(v ?? ""));
      }

      out = out.replace(/\{\s*zoom_label\s*\}/gi, String(vars?.ZOOM_LABEL ?? vars?.zoom_label ?? ""));
      return out;
    }


    // =========================
    // ✅ IMG_SLOT helpers (NEW)
    // - 이미지 섹션이 여러 개일 때, IMG_SLOT(예: IMG_1)을 기준으로
    //   {{IMG_SRC}} 같은 "번호 없는 토큰"을 {{IMG_SRC_1}} 형태로 자동 넘버링
    // =========================
    function parseImgSlotIndex_(v){
      const m = String(v || "").trim().toUpperCase().match(/^IMG_(\d+)$/);
      return m ? Number(m[1]) : 0;
    }

    function applyImgSlotNumbering_(html, imgSlot){
      const n = parseImgSlotIndex_(imgSlot);
      if (!n) return String(html || "");

      // IMG 토큰 패밀리(번호를 붙일 대상)
      const baseTokens = [
        "IMG_ID","IMG_SRC","IMG_HREF","IMG_OW","IMG_OH","IMG_ALT","IMG_TITLE","IMG_SNIPPET",
        // 일부 템플릿은 THUMB_URL을 이미지로도 사용하므로 함께 넘버링
        "THUMB_URL"
      ];

      let out = String(html || "");
      for (const t of baseTokens){
        const re = new RegExp(`{{\\s*${escapeRegExp(t)}\\s*}}`, "g");
        out = out.replace(re, `{{${t}_${n}}}`);
      }
      return out;
    }

    function getImgTokenIndices_(tokenNames){
      const idx = new Set();
      (tokenNames || []).forEach(t=>{
        const m = String(t||"").trim().match(/^(IMG_(?:ID|SRC|HREF|OW|OH|ALT|TITLE|SNIPPET)|THUMB_URL)_(\d+)$/);
        if (m) idx.add(Number(m[2]));
      });
      return Array.from(idx).filter(n=>Number.isFinite(n)).sort((a,b)=>a-b);
    }

    function pickFirstEmptyImgIndex_(tokenNames){
      const indices = getImgTokenIndices_(tokenNames);
      if (!indices.length) return 0;

      const currentVals = getTokenValues_();
      for (const n of indices){
        // "빈 슬롯" 판단: 대표 키(IMG_SRC_n)가 비어 있으면 우선 타겟으로 선택
        const key = `IMG_SRC_${n}`;
        if (!String(currentVals[key] || "").trim()) return n;
      }
      return indices[0];
    }

    function collectSlotsFromManifest_(manifest){
      const slots = [];
      const seen = new Set();

      const sections = Array.isArray(manifest?.sections) ? manifest.sections : [];
      for (const sec of sections){
        const slot = (sec && typeof sec === "object" && sec.vars && sec.vars.SLOT)
          ? String(sec.vars.SLOT).trim()
          : "";

        if (slot && !seen.has(slot)){
          seen.add(slot);
          slots.push(slot);
        }
      }

      if (slots.length === 0) slots.push("BODY");
      return slots;
    }

    
    async function collectTokensFromTemplate_(manifest, slotNames){
      const supported = new Set([
        "THUMB_URL","CANONICAL_URL","YEAR","MONTH","YEAR_NAV_JSON",
        "IMG_ID","IMG_SRC","IMG_HREF","IMG_OW","IMG_OH","IMG_ALT","IMG_TITLE","IMG_SNIPPET",
        "ZOOM_LABEL"
      ]);

      // ✅ 이미지 섹션이 여러 개일 때, IMG_SLOT 기준으로 번호 토큰을 만들기 위한 패밀리
      const imgFamily = new Set([
        "IMG_ID","IMG_SRC","IMG_HREF","IMG_OW","IMG_OH","IMG_ALT","IMG_TITLE","IMG_SNIPPET",
        "THUMB_URL"
      ]);

      const reserved = new Set(["TITLE","NAV","FOOTER","BODY"]);
      (slotNames || []).forEach(s=>reserved.add(String(s)));

      const found = new Set();
      const sections = Array.isArray(manifest?.sections) ? manifest.sections : [];

      for (const sec of sections){
        const name =
          (typeof sec === "string") ? sec.trim() :
          (sec && typeof sec === "object") ? String(sec.name || "").trim() : "";

        if (!name) continue;

        const secVarsObj =
          (sec && typeof sec === "object" && sec.vars && typeof sec.vars === "object") ? sec.vars : {};
        const imgSlotN = parseImgSlotIndex_(secVarsObj.IMG_SLOT);

        let html = "";
        try{
          html = await getSectionHtml_(name);
        }catch(e){
          html = "";
          const prev = $("debug").textContent || "";
          $("debug").textContent =
            prev + `\n[SECTION LOAD FAIL] ${name} :: ` + (e?.message || e);
        }

        const re = /{{\s*([A-Z0-9_]+)\s*}}/g;
        let m;
        while ((m = re.exec(String(html))) !== null){
          const token = String(m[1] || "").trim();
          if (!token) continue;
          if (reserved.has(token)) continue;

          // ✅ IMG_SLOT이 잡히고 + 이미지 토큰이면, 번호를 붙여서 입력칸이 여러 개 생기게 함
          if (imgSlotN && imgFamily.has(token)){
            found.add(`${token}_${imgSlotN}`);
            continue;
          }

          if (supported.has(token)) found.add(token);
        }

        // {zoom_label} (소문자)도 허용(기존 호환)
        if (/\{\s*zoom_label\s*\}/i.test(String(html))) {
          if (!reserved.has("ZOOM_LABEL") && supported.has("ZOOM_LABEL")) {
            found.add("ZOOM_LABEL");
          }
        }
      }

      return Array.from(found);
    }

    function renderDynamicFields_
(slotNames, tokenNames){
      const slotBox = $("slotFields");
      const tokBox  = $("tokenFields");
      slotBox.innerHTML = "";
      tokBox.innerHTML = "";

      let __imgListCache = null;

      
      async function initImgPickerUIForIndex_(n){
        const suffix = n ? String(n) : "base";
        const sel = document.getElementById(`imgDbSelect_${suffix}`);
        const btn = document.getElementById(`btnImgDbApply_${suffix}`);
        const pv  = document.getElementById(`imgDbPreview_${suffix}`);
        if (!sel || !btn) return;

        sel.innerHTML = `<option value="">이미지 선택...</option>`;

        try{
          if (!__imgListCache) __imgListCache = await imgList_();

          for (const it of __imgListCache){
            const id = String(it.id || "");
            const name = String(it.base_name || it.drive_name || "");
            const opt = document.createElement("option");
            opt.value = id;
            opt.textContent = name ? `${id} — ${name}` : id;
            sel.appendChild(opt);
          }

          sel.addEventListener("change", () => {
            const id = sel.value;
            const hit = (__imgListCache || []).find(x => String(x.id) === String(id));
            if (!hit) { if (pv) pv.textContent = ""; return; }

            const thumb = imgThumbUrl_(hit.drive_file_id) || hit.img_src || "";
            const href  = hit.img_href || hit.drive_view_url || "";

            if (!pv) return;
            pv.innerHTML = thumb
              ? `미리보기: <a class="pm-link" href="${href}" target="_blank">Drive 열기</a><br><img src="${thumb}" style="max-width:260px;border-radius:10px;border:1px solid rgba(15,23,42,0.14);margin-top:6px;" />`
              : `미리보기 없음`;
          });

          btn.addEventListener("click", async () => {
            const id = sel.value;
            if (!id) { setStatus("이미지를 먼저 선택하세요.", false); return; }

            setStatus("이미지 상세 불러오는 중...", true);
            const item = await imgGet_(id);
            if (!item) { setStatus("이미지 상세를 가져오지 못했습니다.", false); return; }

            const toksArr = (templateState.tokens || []);
            const toks = new Set(toksArr);
            const patch = {};

            // ✅ 이 UI는 특정 IMG 인덱스(n)에만 채운다.
            const put = (baseKey, val) => {
              if (n){
                const k = `${baseKey}_${n}`;
                if (toks.has(k)) patch[k] = val;
              } else {
                if (toks.has(baseKey)) patch[baseKey] = val;
              }
            };

            put("IMG_ID", item.id || "");
            put("IMG_SRC", imgThumbUrl_(item.drive_file_id) || item.img_src || "");
            put("IMG_HREF", item.img_href || item.drive_view_url || "");
            put("IMG_ALT", item.img_alt || "");
            put("IMG_TITLE", item.img_title || "");
            put("IMG_SNIPPET", item.snippet || "");
            put("IMG_OW", item.orig_w || "");
            put("IMG_OH", item.orig_h || "");

            // 일부 템플릿은 THUMB_URL을 이미지로도 사용
            put("THUMB_URL", imgThumbUrl_(item.drive_file_id) || item.img_src || "");

            setTokenValues_(patch);
            scheduleAssemblePreview_();
            setStatus(`이미지 토큰 자동입력 완료: ${id} → ${n ? "IMG_"+n : "IMG"}`, true);
          });

        }catch(e){
          setStatus("이미지 DB 목록 로드 실패: " + (e?.message || e), false);
          if (pv) pv.textContent = String(e?.message || e);
        }
      }


      for (const slot of (slotNames || [])){
        const wrap = document.createElement("div");
        wrap.className = "pm-dyn-item";
        wrap.innerHTML = `
          <div class="pm-dyn-key">${escapeHtml(slot)}</div>
          <textarea class="pm-textarea pm-dyn-textarea" data-slot="${escapeHtml(slot)}"
            placeholder="템플릿 SLOT: ${escapeHtml(slot)}"></textarea>
        `;
        slotBox.appendChild(wrap);
      }

      if (!tokenNames || tokenNames.length === 0){
        const empty = document.createElement("div");
        empty.className = "pm-muted pm-small";
        empty.textContent = "추가 토큰(THUMB_URL, CANONICAL_URL, YEAR, MONTH)이 감지되지 않았습니다.";
        tokBox.appendChild(empty);

        attachDynamicPreviewListeners_();
        return;
      }

      const needsImg =
        (tokenNames || []).some(t => /^IMG_/.test(String(t||""))) ||
        (tokenNames || []).includes("THUMB_URL");

      
      if (needsImg) {
        // ✅ 번호 토큰이 있으면(IMG_*_1, IMG_*_2 ...) 그룹별로 이미지 선택 UI를 각각 만든다.
        // ✅ 번호 토큰이 없으면 기본(IMG) 1개만 만든다.
        const indices = getImgTokenIndices_(tokenNames || []);
        const groups = indices.length ? indices : [0];

        for (const n of groups){
          const suffix = n ? String(n) : "base";
          const label  = n ? `IMG_${n}` : "IMG";

          const wrap = document.createElement("div");
          wrap.className = "pm-dyn-item";
          wrap.style.gridColumn = "1 / -1";
          wrap.innerHTML = `
            <div class="pm-dyn-key">이미지(DB) 선택 · ${label}</div>
            <div class="pm-row" style="margin:8px 0 0;">
              <select id="imgDbSelect_${suffix}" class="pm-select" style="min-width:320px;"></select>
              <button id="btnImgDbApply_${suffix}" class="pm-btn">선택 이미지 토큰 자동입력</button>
              <span class="pm-muted pm-small">※ ${label} 토큰 묶음에만 반영</span>
            </div>
            <div id="imgDbPreview_${suffix}" class="pm-muted pm-small" style="margin-top:8px;"></div>
          `;
          tokBox.appendChild(wrap);
          initImgPickerUIForIndex_(n);
        }
      }


      for (const tok of tokenNames){
        const wrap = document.createElement("div");
        wrap.className = "pm-dyn-item";

        const isYearNav = String(tok) === "YEAR_NAV_JSON";

        wrap.innerHTML = `
          <div class="pm-dyn-key">${escapeHtml(tok)}</div>
          ${
            isYearNav
              ? `<textarea class="pm-textarea pm-dyn-textarea" data-token="${escapeHtml(tok)}"
                   placeholder="${escapeHtml(tokenPlaceholder_(tok))}"></textarea>`
              : `<input class="pm-input" data-token="${escapeHtml(tok)}" style="min-width:0; width:100%;"
                   placeholder="${tokenPlaceholder_(tok)}" />`
          }
        `;
        tokBox.appendChild(wrap);
      }

      attachDynamicPreviewListeners_();
    }

    function tokenPlaceholder_(tok){
      switch(String(tok||"")){
        case "THUMB_URL": return "예: https://... (썸네일 이미지 URL)";
        case "CANONICAL_URL": return "예: https://www.cheesehistory.com/... (정식 URL)";
        case "YEAR": return "예: 2026";
        case "MONTH": return "예: 01";
        case "YEAR_NAV_JSON": return "줄입력 예:\n2022,https://.../2022.html\n2023,https://.../2023.html\n2024,";
        case "ZOOM_LABEL": return "예: 이미지 크게보기 (확대 링크 문구)";
        default: return "";
      }
    }

    function getSlotValues_(){
      const out = {};
      document.querySelectorAll("[data-slot]").forEach(el=>{
        const k = el.getAttribute("data-slot");
        if (!k) return;
        out[k] = (el.value || "");
      });
      return out;
    }

    function setSlotValues_(map){
      const m = map || {};
      document.querySelectorAll("[data-slot]").forEach(el=>{
        const k = el.getAttribute("data-slot");
        if (!k) return;
        el.value = (m[k] !== undefined && m[k] !== null) ? String(m[k]) : "";
      });
    }

    function getTokenValues_(){
      const out = {};
      document.querySelectorAll("[data-token]").forEach(el=>{
        const k = el.getAttribute("data-token");
        if (!k) return;
        out[k] = (el.value || "");
      });
      return out;
    }

    function setTokenValues_(map){
      const m = map || {};
      document.querySelectorAll("[data-token]").forEach(el=>{
        const k = el.getAttribute("data-token");
        if (!k) return;
        el.value = (m[k] !== undefined && m[k] !== null) ? String(m[k]) : "";
      });
    }

    function compactVars_(obj){
      const out = {};
      for (const [k,v] of Object.entries(obj || {})){
        const s = (v === undefined || v === null) ? "" : String(v);
        if (s.trim() === "") continue;
        out[k] = s;
      }
      return out;
    }

    function buildVarsForAssemble_(){
      const title = $("title").value.trim();
      const slotVals  = getSlotValues_();
      const tokenVals = getTokenValues_();

      const z = String((tokenVals.ZOOM_LABEL ?? tokenVals.zoom_label ?? "")).trim();
      tokenVals.ZOOM_LABEL = z || "이미지 크게보기";
      tokenVals.zoom_label = tokenVals.ZOOM_LABEL;

      if (tokenVals.YEAR_NAV_JSON && !String(tokenVals.YEAR_NAV_JSON).trim().startsWith("[")) {
        tokenVals.YEAR_NAV_JSON = lineToYearNavJson_(tokenVals.YEAR_NAV_JSON);
      }

      const vars = {
        TITLE: title,
        title: title,
        NAV: "",
        FOOTER: "",
        nav: "",
        footer: "",
        ...compactVars_(slotVals),
        ...compactVars_(tokenVals)
      };

      return vars;
    }

    function lineToYearNavJson_(txt){
      const items = String(txt || "")
        .trim()
        .split(/\r?\n/)
        .map(s => s.trim())
        .filter(Boolean)
        .map(line => {
          const idx = line.indexOf(",");
          if (idx < 0) return null;
          const year = line.slice(0, idx).trim();
          const href = line.slice(idx + 1).trim();
          if (!year) return null;
          return { year: year, href: href };
        })
        .filter(Boolean);

      return JSON.stringify(items);
    }

    async function analyzeAndRenderTemplate_(tplId){
      templateState.templateId = tplId || "";
      templateState.manifest = null;
      templateState.slots = [];
      templateState.tokens = [];

      if (!tplId){
        renderDynamicFields_(["BODY"], []);
        return;
      }

      try{
        const manifest = await getTemplateManifest_(tplId);
        templateState.manifest = manifest;

        const slotNames = collectSlotsFromManifest_(manifest);
        const tokenNames = await collectTokensFromTemplate_(manifest, slotNames);

        templateState.slots = slotNames;
        templateState.tokens = tokenNames;

        const prevSlots = getSlotValues_();
        const prevToks  = getTokenValues_();

        renderDynamicFields_(slotNames, tokenNames);

        setSlotValues_(prevSlots);
        setTokenValues_(prevToks);

      }catch(e){
        renderDynamicFields_(["BODY"], []);
        setStatus("템플릿 분석 실패: " + (e?.message || e), false);
        setDebug(String(e && e.stack ? e.stack : e));
      }
    }

    async function assembleHtmlFromManifest_(manifest, templateId, vars){
      const tid = String(manifest?.template_id || manifest?.id || templateId).trim();
      const tver = String(manifest?.template_ver || manifest?.ver || "").trim();

      const sections = Array.isArray(manifest?.sections) ? manifest.sections : [];
      if (!sections.length) throw new Error("TEMPLATE_SECTIONS_EMPTY");

      const parts = [];

      for (const sec of sections){
        const secName =
          (typeof sec === "string") ? sec.trim() :
          (sec && typeof sec === "object") ? String(sec.name || "").trim() : "";

        if (!secName) continue;

        let secHtml = await getSectionHtml_(secName);

        const secVarsRaw = (sec && typeof sec === "object" && sec.vars && typeof sec.vars === "object")
          ? sec.vars
          : {};

        const slotName = (secVarsRaw && secVarsRaw.SLOT) ? String(secVarsRaw.SLOT).trim() : "";

        if (slotName){
          const slotVal = (vars && (vars[slotName] ?? vars[String(slotName).toUpperCase()])) ?? "";

          if (String(slotVal).length > 0){
            secHtml = secHtml.replace(/{{\s*BODY\s*}}/g, String(slotVal));
          } else {
            secHtml = secHtml.replace(/{{\s*BODY\s*}}/g, `{{${slotName}}}`);
          }

          secHtml = secHtml
            .replace(/<!--\s*BODY_START\s*-->/gi, `<!-- BODY_START:${slotName} -->`)
            .replace(/<!--\s*BODY_END\s*-->/gi, `<!-- BODY_END:${slotName} -->`)
            .replace(/<!--\s*BODY_START\s*:\s*BODY\s*-->/gi, `<!-- BODY_START:${slotName} -->`)
            .replace(/<!--\s*BODY_END\s*:\s*BODY\s*-->/gi, `<!-- BODY_END:${slotName} -->`);
        }

        // ✅ IMG_SLOT이 있으면, 섹션 내부의 {{IMG_SRC}} 같은 토큰을 {{IMG_SRC_n}} 형태로 먼저 넘버링
        const imgSlot = (secVarsRaw && secVarsRaw.IMG_SLOT) ? String(secVarsRaw.IMG_SLOT).trim() : "";
        if (imgSlot) secHtml = applyImgSlotNumbering_(secHtml, imgSlot);

        const secVars = { ...secVarsRaw };
        secHtml = replaceTokens_(secHtml, { ...vars, ...secVars });

        parts.push(secHtml);
      }

      let assembled = parts.join("\n");

      const metaHeader =
        `<!-- template_id: ${tid} -->\n` +
        (tver ? `<!-- template_ver: ${tver} -->\n` : "");

      const tokensMeta = buildTokensMetaComment_(vars);

      assembled = metaHeader + tokensMeta + assembled;
      return { html: assembled, manifest };
    }

    async function assembleHtmlFromTemplate_(templateId, vars){
      const manifest = await getTemplateManifest_(templateId);
      return assembleHtmlFromManifest_(manifest, templateId, vars);
    }

    async function assembleHtmlUsingState_(templateId, vars){
      if (!templateId) throw new Error("TEMPLATE_ID_REQUIRED");

      if (!templateState.manifest || templateState.templateId !== templateId){
        templateState.templateId = templateId;
        templateState.manifest = await getTemplateManifest_(templateId);
      }
      return assembleHtmlFromManifest_(templateState.manifest, templateId, vars);
    }

    async function initTemplateSelect_(){
      const sel = $("templateSelect");
      sel.innerHTML = "";

      const opt0 = document.createElement("option");
      opt0.value = "";
      opt0.textContent = "템플릿 선택...";
      sel.appendChild(opt0);

      try{
        setStatus("템플릿 목록 불러오는 중(Drive)...", true);
        const items = await listTemplates_();

        for (const it of items){
          const id = String(it.id || it.template_id || it.name || "")
            .replace(/\.json$/i, "")
            .trim();
          if (!id) continue;

          const opt = document.createElement("option");
          opt.value = id;
          opt.textContent = id;
          sel.appendChild(opt);
        }

        setStatus(`템플릿 ${items.length}개 로드됨`, true);
      }catch(e){
        setStatus("템플릿 목록 불러오기 실패: " + (e?.message || e), false);
        showBanner(String(e && e.stack ? e.stack : e));
      }
    }

    // ===== UI actions =====
    async function applyTemplateNew(){
      const tplId = $("templateSelect").value;
      if (!tplId) return setStatus("템플릿을 먼저 선택하세요.", false);

      try{
        setBusy_(true);
        hideBanner();
        setStatus("템플릿 적용(새로) 중...", true);

        await analyzeAndRenderTemplate_(tplId);

        setSlotValues_({});

        const out = await assembleHtmlFromTemplate_(tplId, buildVarsForAssemble_());
        $("html").value = out.html;
        syncCharCount();

        setStatus("템플릿 적용 완료(새로). SLOT 입력칸을 채운 뒤 저장하세요.", true);

      }catch(e){
        setStatus("템플릿 적용 오류: " + (e?.message || e), false);
        setDebug(String(e && e.stack ? e.stack : e));
      }finally{
        setBusy_(false);
      }
    }

    async function rewrapTemplateKeepBody(){
      const tplId = $("templateSelect").value;
      if (!tplId) return setStatus("템플릿을 먼저 선택하세요.", false);

      try{
        setBusy_(true);
        hideBanner();
        setStatus("래퍼 재적용(본문 유지) 중...", true);

        const out = await assembleHtmlFromTemplate_(tplId, buildVarsForAssemble_());
        $("html").value = out.html;
        syncCharCount();

        setStatus("래퍼 재적용 완료(본문 유지).", true);

      }catch(e){
        setStatus("래퍼 재적용 오류: " + (e?.message || e), false);
        setDebug(String(e && e.stack ? e.stack : e));
      }finally{
        setBusy_(false);
      }
    }

    // ===== Post list/load =====
    function setFromSelect(){
      const v = $("postSelect").value;
      if (v) $("id").value = v;
      setStickyId_();
    }

    function getTargetId(){
      const fromSelect = $("postSelect").value;
      const fromInput  = $("id").value.trim();
      return fromSelect || fromInput || "";
    }

    async function refreshList(selectId){
      try{
        setBusy_(true);
        hideBanner();
        setStatus("목록 불러오는 중...", true);
        const res = await apiGet("listPosts");
        if (!res || !res.ok) return setStatus("목록 불러오기 실패: " + (res?.message||""), false);

        const sel = $("postSelect");
        sel.innerHTML = "";
        const items = res.items || [];

        const opt0 = document.createElement("option");
        opt0.value = "";
        opt0.textContent = "선택...";
        sel.appendChild(opt0);

        for (const it of items){
          const opt = document.createElement("option");
          opt.value = it.id;
          opt.textContent = it.id + (it.title ? ` — ${it.title}` : "");
          sel.appendChild(opt);
        }

        if (selectId){
          sel.value = selectId;
          $("id").value = selectId;
        }

        setStickyId_();
        setStatus(`목록 ${items.length}건`, true);
      }catch(e){
        setStatus("목록 불러오기 오류: " + (e?.message || e), false);
        showBanner(String(e && e.stack ? e.stack : e));
      }finally{
        setBusy_(false);
      }
    }

    async function loadPost(){
      const id = getTargetId();
      if (!id) return setStatus("id를 선택하거나 입력하세요.", false);

      try{
        setBusy_(true);
        hideBanner();
        setStatus(`불러오는 중: ${id}`, true);

        const res = await apiGet("getPost", { id });
        if (!res || !res.ok) return setStatus("불러오기 실패: " + (res?.message||""), false);

        current = res.post;

        $("id").value = current.id;
        $("title").value = current.title || "";
        $("html").value = current.html || "";

        const meta = readTemplateMeta_(current.html || "");
        if (meta.template_id && $("templateSelect")) {
          $("templateSelect").value = meta.template_id;
          await analyzeAndRenderTemplate_(meta.template_id);
        } else {
          await analyzeAndRenderTemplate_($("templateSelect").value || "");
        }

        const bodies = extractBodies_(current.html || "");
        setSlotValues_(bodies);

        const toks = extractTokensMetaFromHtml_(current.html || "");
        setTokenValues_(toks);

        syncCharCount();
        setMeta(current);
        setBloggerMeta(null);
        setStickyId_();

        // 라벨 필드는 시트에 blogger_labels가 있다면 여기서 채울 수도 있지만,
        // 현재 html엔 그 필드를 직접 받는 로직이 없어서(서버 응답 확장 시) 추후 연결 권장

        setStatus("불러오기 완료", true);
      }catch(e){
        setStatus("불러오기 오류: " + (e?.message || e), false);
        setDebug(String(e && e.stack ? e.stack : e));
      }finally{
        setBusy_(false);
      }
    }

    // ===== Drive HTML upsert/read =====
    async function exportToDrive(){
      const id = getTargetId();
      if (!id) return setStatus("id가 필요합니다.", false);

      try{
        setBusy_(true);
        hideBanner();

        const tplId = $("templateSelect").value;
        if (tplId){
          setStatus("저장 전 최종 HTML 생성(템플릿 조립) 중...", true);
          const out = await assembleHtmlFromTemplate_(tplId, buildVarsForAssemble_());
          $("html").value = out.html;
          syncCharCount();
        }

        const payload = {
          id,
          title: $("title").value.trim(),
          html: $("html").value
        };

        setStatus("Drive 저장/업데이트 중...", true);
        const res = await apiPost("driveUpsert", payload);
        setDebug(res);

        if (!res || !res.ok) return setStatus("Drive 저장 실패: " + (res?.message||""), false);

        setStatus(`Drive 저장 완료: ${res.file?.name || ""}`, true);
        await refreshList(id);
        await loadPost();

      }catch(e){
        setStatus("Drive 저장 오류: " + (e?.message || e), false);
        setDebug(String(e && e.stack ? e.stack : e));
      }finally{
        setBusy_(false);
      }
    }

    async function importFromDrive(){
      const id = getTargetId();
      if (!id) return setStatus("id가 필요합니다.", false);

      try{
        setBusy_(true);
        hideBanner();
        setStatus("Drive에서 불러오는 중...", true);

        const res = await apiGet("driveReadById", { id });
        if (!res || !res.ok) return setStatus("Drive 불러오기 실패: " + (res?.message||""), false);

        const html = res.html || "";
        $("html").value = html;

        const meta = readTemplateMeta_(html);
        if (meta.template_id) {
          $("templateSelect").value = meta.template_id;
          await analyzeAndRenderTemplate_(meta.template_id);
        } else {
          await analyzeAndRenderTemplate_($("templateSelect").value || "");
        }

        setSlotValues_(extractBodies_(html));
        setTokenValues_(extractTokensMetaFromHtml_(html));

        syncCharCount();
        setStickyId_();
        setStatus("Drive 불러오기 완료", true);

      }catch(e){
        setStatus("Drive 불러오기 오류: " + (e?.message || e), false);
        setDebug(String(e && e.stack ? e.stack : e));
      }finally{
        setBusy_(false);
      }
    }

    // ===== Blogger =====
    async function exportToBlogger(){
      const id = getTargetId();
      if (!id) return setStatus("id가 필요합니다.", false);

      try{
        setBusy_(true);

        const tplId = $("templateSelect").value;
        if (tplId){
          setStatus("업로드 전 최종 HTML 생성(템플릿 조립) 중...", true);
          const out = await assembleHtmlFromTemplate_(tplId, buildVarsForAssemble_());
          $("html").value = out.html;
          syncCharCount();
        }

        syncTopLabelControls_();
        const labelsCsv = $("bloggerLabels").value.trim();
        const actionUi = $("bloggerLabelsAction").value || "replace";

        const payload = {
          id,
          title: $("title").value.trim(),
          html: $("html").value,
          publish: $("bloggerPublish").checked ? "true" : "false",
          labels: labelsCsv,
          labels_action: labelsCsv ? actionUi : "keep" // ✅ 비어있으면 기존 라벨 유지
        };

        hideBanner();
        setStatus("Blogger 업로드/수정 중...", true);

        const res = await apiPost("bloggerUpsert", payload);
        setDebug(res);

        if (!res || !res.ok) return setStatus("Blogger 업로드 실패: " + (res?.message||""), false);

        setBloggerMeta({ url: res.url, post_id: res.post_id, status: res.status });
        setStatus(`Blogger ${res.status === 'published' ? '발행' : '초안'} 완료`, true);
      }catch(e){
        setStatus("Blogger 업로드 오류: " + (e?.message || e), false);
        setDebug(String(e && e.stack ? e.stack : e));
      }finally{
        setBusy_(false);
      }
    }

    async function importFromBlogger(){
      const id = getTargetId();
      if (!id) return setStatus("id가 필요합니다.", false);

      try{
        setBusy_(true);
        hideBanner();
        setStatus("Blogger에서 불러오는 중...", true);

        const res = await apiGet("bloggerRead", { id });
        setDebug(res);

        if (!res || !res.ok) return setStatus("Blogger 불러오기 실패: " + (res?.message||""), false);

        $("title").value = res.title || $("title").value;
        $("html").value = res.html || "";
        syncCharCount();

        const html = $("html").value || "";
        const meta = readTemplateMeta_(html);
        if (meta.template_id) {
          $("templateSelect").value = meta.template_id;
          await analyzeAndRenderTemplate_(meta.template_id);
        } else {
          await analyzeAndRenderTemplate_($("templateSelect").value || "");
        }

        setSlotValues_(extractBodies_(html));
        setTokenValues_(extractTokensMetaFromHtml_(html));

        const labelsArr = Array.isArray(res.labels) ? res.labels : [];
        $("currentLabelsView").textContent = "현재 라벨: " + (labelsArr.length ? labelsArr.join(", ") : "-");

        // 상단/하단 라벨 입력칸에도 반영(비어있을 때만)
        if (!$("bloggerLabels").value.trim()){
          $("bloggerLabels").value = labelsArr.join(", ");
          $("bloggerLabelsTop").value = labelsArr.join(", ");
        }

        setBloggerMeta({ url: res.url, post_id: res.post_id, status: "loaded" });
        setStickyId_();
        setStatus("Blogger 불러오기 완료", true);
      }catch(e){
        setStatus("Blogger 불러오기 오류: " + (e?.message || e), false);
        setDebug(String(e && e.stack ? e.stack : e));
      }finally{
        setBusy_(false);
      }
    }

    async function patchBloggerLabels(){
      const id = getTargetId();
      if (!id) return setStatus("id가 필요합니다.", false);

      syncTopLabelControls_();
      const labels = $("bloggerLabels").value.trim();
      const action = $("bloggerLabelsAction").value || "replace";

      try{
        setBusy_(true);
        hideBanner();
        setStatus("라벨 적용 중...", true);

        const res = await apiPost("bloggerPatchLabels", { id, labels, action });
        setDebug(res);

        if (!res || !res.ok) return setStatus("라벨 적용 실패: " + (res?.message||""), false);

        setStatus(`라벨 적용 완료 (${(res.labels||[]).length}개)`, true);
        if (res.url) setBloggerMeta({ url: res.url, post_id: res.post_id, status: "labels_updated" });

        // 현재라벨 표시 갱신
        $("currentLabelsView").textContent = "현재 라벨: " + ((res.labels||[]).length ? res.labels.join(", ") : "-");
      }catch(e){
        setStatus("라벨 적용 오류: " + (e?.message || e), false);
        setDebug(String(e && e.stack ? e.stack : e));
      }finally{
        setBusy_(false);
      }
    }

    async function revertBloggerToDraft(){
      const id = getTargetId();
      if (!id) return setStatus("id가 필요합니다.", false);

      try{
        setBusy_(true);
        hideBanner();
        setStatus("초안으로 되돌리는 중...", true);

        const res = await apiPost("bloggerRevert", { id });
        setDebug(res);

        if (!res || !res.ok) return setStatus("초안 되돌리기 실패: " + (res?.message||""), false);

        setBloggerMeta({ url: res.url, post_id: res.post_id, status: "draft" });
        setStatus("초안으로 되돌리기 완료", true);
      }catch(e){
        setStatus("초안 되돌리기 오류: " + (e?.message || e), false);
        setDebug(String(e && e.stack ? e.stack : e));
      }finally{
        setBusy_(false);
      }
    }

    function clearEditor(){
      $("title").value = "";
      $("html").value = "";
      setSlotValues_({});
      setTokenValues_({});
      syncCharCount();
      setStatus("편집창을 비웠습니다.", true);
      setStickyId_();
    }

    /* =========================
       ✅ 원클릭 파이프라인 (NEW)
       - Drive 저장 → Blogger 업로드
    ========================= */
    async function pipelinePublish_(publish){
      const id = getTargetId();
      if (!id) return setStatus("id가 필요합니다.", false);

      // publish 강제
      const prev = $("bloggerPublish").checked;
      $("bloggerPublish").checked = !!publish;

      try{
        setBusy_(true);
        setStatus(publish ? "원클릭 발행 시작..." : "원클릭 초안 저장 시작...", true);

        // 1) Drive 저장
        await exportToDrive();

        // 2) Blogger 업로드
        await exportToBlogger();

        setStatus(publish ? "원클릭 발행 완료" : "원클릭 초안 저장 완료", true);
      }catch(e){
        setStatus("원클릭 작업 오류: " + (e?.message || e), false);
        setDebug(String(e && e.stack ? e.stack : e));
      }finally{
        $("bloggerPublish").checked = prev;
        setBusy_(false);
      }
    }

    /* =========================
       ✅ ID 자동생성(분류 기반)
    ========================= */
    function mapCategoryToPrefix(cat){
      const m = {
        monthly_news: "NM",
        timeline_kr_cn_jp: "TL",
        genealogy_series: "GN",
        etc: "ETC",
      };
      return m[cat] || "POST";
    }

    function yyyymmddNow(){
      const d = new Date();
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2, "0");
      const day = String(d.getDate()).padStart(2, "0");
      return `${y}${m}${day}`;
    }

    async function regenId(){
      const cat = $("category").value;

      if (!cat) {
        setStatus("분류를 먼저 선택하세요.", false);
        return;
      }

      if (cat === "manual"){
        setStatus("수동입력 분류입니다. ID를 직접 입력하세요.", true);
        $("id").disabled = false;
        $("id").focus();
        setStickyId_();
        return;
      }

      const prefix = mapCategoryToPrefix(cat);
      const dateToken = yyyymmddNow();
      const base = `${prefix}_${dateToken}_`;

      try{
        setBusy_(true);
        setStatus("ID 생성 중...", true);

        const res = await apiGet("listPosts");
        if (!res || !res.ok) throw new Error(res?.message || "LIST_FAILED");

        let maxSeq = 0;
        for (const it of (res.items || [])){
          const id = String(it.id || "");
          if (!id.startsWith(base)) continue;
          const tail = id.slice(base.length);
          const n = parseInt(tail, 10);
          if (!isNaN(n)) maxSeq = Math.max(maxSeq, n);
        }

        const nextSeq = String(maxSeq + 1).padStart(2, "0");
        $("id").value = `${base}${nextSeq}`;
        $("id").disabled = true;

        setStickyId_();
        setStatus(`ID 생성 완료: ${$("id").value}`, true);
      }catch(e){
        setStatus("ID 생성 오류: " + (e?.message || e), false);
        setDebug(String(e && e.stack ? e.stack : e));
      }finally{
        setBusy_(false);
      }
    }

    function onCategoryChange(){
      const cat = $("category").value;

      if (cat === "manual"){
        $("id").disabled = false;
        setStatus("수동입력: ID를 직접 입력하세요.", true);
        setStickyId_();
        return;
      }

      $("id").disabled = true;
      if (cat) regenId();
    }

    // templateSelect 변경 시: SLOT/토큰 입력칸 재구성
    $("templateSelect").addEventListener("change", async ()=>{
      const tplId = $("templateSelect").value || "";
      await analyzeAndRenderTemplate_(tplId);
      attachDynamicPreviewListeners_();
      scheduleAssemblePreview_();
    });

    /* =========================
       버튼 연결
    ========================= */
    $("btnRefresh").addEventListener("click", ()=>refreshList());
    $("btnLoad").addEventListener("click", loadPost);
    $("btnSetFromSelect").addEventListener("click", setFromSelect);

    $("btnApplyTemplate").addEventListener("click", applyTemplateNew);
    $("btnRewrapTemplate").addEventListener("click", rewrapTemplateKeepBody);

    $("btnDriveUpsert").addEventListener("click", exportToDrive);
    $("btnDriveRead").addEventListener("click", importFromDrive);
    $("btnClear").addEventListener("click", clearEditor);

    $("btnBloggerUpsert").addEventListener("click", exportToBlogger);
    $("btnBloggerRead").addEventListener("click", importFromBlogger);

    $("btnBloggerLabels").addEventListener("click", patchBloggerLabels);
    $("btnBloggerRevert").addEventListener("click", revertBloggerToDraft);

    $("btnRegenId").addEventListener("click", regenId);
    $("category").addEventListener("change", onCategoryChange);

    // ✅ Sticky Action Bar buttons (NEW)
    $("btnQuickPublish").addEventListener("click", ()=>pipelinePublish_(true));
    $("btnQuickDraft").addEventListener("click", ()=>pipelinePublish_(false));
    $("btnQuickDriveSave").addEventListener("click", exportToDrive);
    $("btnQuickBloggerUpsert").addEventListener("click", exportToBlogger);
    $("btnQuickBloggerRead").addEventListener("click", importFromBlogger);
    $("btnQuickLabels").addEventListener("click", patchBloggerLabels);

    // postSelect 바뀌면 sticky id 갱신
    $("postSelect").addEventListener("change", ()=>{
      const v = $("postSelect").value || "";
      if (v) $("id").value = v;   // ✅ 선택값을 ID칸에 자동 반영
      setStickyId_();
    });

    // init
    (async function init(){
      setDebug("");
      renderDynamicFields_(["BODY"], []);
      setStickyId_();
      await refreshList();
      await initTemplateSelect_();
      setStatus("준비됨", true);
    })();
  })();

  function escapeHtml(s){
    return String(s||"").replace(/[&<>"']/g, (m)=>({
      "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
    }[m]));
  }
  </script>
</body>
</html>
