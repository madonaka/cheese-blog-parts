<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>포스트 관리</title>

  <!-- ✅ 메인 관리자 CSS 재사용 -->
  <link rel="stylesheet" href="./admin.css" />

  <style>
    /* ===== page local styles ===== */
    .pm-wrap{ padding: 14px; }

    .pm-card{
      background:#fff;
      border:1px solid rgba(15,23,42,0.14);
      border-radius:14px;
      padding:14px;
      margin-bottom:12px;
      box-shadow:0 10px 24px rgba(15,23,42,0.06);
    }

    .pm-row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .pm-label{ font-weight:800; }

    .pm-input, .pm-select{
      padding:10px 12px;
      border:1px solid rgba(15,23,42,0.2);
      border-radius:10px;
      min-width:280px;
      background:#fff;
    }

    .pm-title{ min-width:420px; }

    .pm-textarea{
      width:100%;
      min-height:420px;
      padding:12px;
      border:1px solid rgba(15,23,42,0.2);
      border-radius:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size:13px;
      line-height:1.45;
    }

    .pm-btn{
      padding:10px 12px;
      border-radius:10px;
      border:1px solid rgba(15,23,42,0.18);
      background:#fff;
      cursor:pointer;
      font-weight:800;
    }

    .pm-btn.primary{ background:#111827; color:#fff; border-color:#111827; }
    .pm-btn.danger{ background:#b91c1c; color:#fff; border-color:#b91c1c; }

    .pm-muted{ color:#6b7280; font-size:13px; }
    .pm-status{ margin-top:10px; font-size:13px; }
    .pm-status.ok{ color:#047857; }
    .pm-status.err{ color:#b91c1c; }

    .pm-meta{ display:grid; grid-template-columns: 140px 1fr; gap:8px 12px; margin-top:10px; }
    .pm-meta div{ padding:6px 0; }

    .pm-link{ color:#2563eb; font-weight:800; text-decoration:none; }

    .pm-pill{
      display:inline-block;
      padding:3px 8px;
      border-radius:999px;
      border:1px solid rgba(15,23,42,0.15);
      font-size:12px;
      margin-left:8px;
    }

    .pm-small{ font-size:12px; color:#6b7280; }

    .pm-banner{
      margin: 0 0 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(185,28,28,0.25);
      background: rgba(185,28,28,0.06);
      color:#7f1d1d;
      font-weight:800;
      font-size:13px;
      display:none;
      white-space:pre-line;
    }

    /* ===== dynamic fields ===== */
    .pm-dyn-grid{
      display:grid;
      grid-template-columns: 120px 1fr;
      gap:10px 12px;
      align-items:start;
    }
    @media (max-width: 980px){
      .pm-dyn-grid{ grid-template-columns: 1fr; }
    }
    .pm-dyn-item{
      border:1px solid rgba(15,23,42,0.12);
      border-radius:12px;
      padding:10px;
      background:rgba(15,23,42,0.02);
    }
    .pm-dyn-key{ font-weight:900; margin:0 0 6px; }
    .pm-dyn-help{ margin:0 0 10px; }
    .pm-dyn-textarea{ min-height:200px; }
    .pm-hr{ height:1px; background:rgba(15,23,42,0.10); margin:12px 0; }
  </style>
</head>

<body>
  <div class="admin-shell">
    <div id="admin-header-slot"></div>

    <div class="admin-main">
      <aside id="admin-menu-slot" class="admin-sidebar"></aside>

      <main class="admin-content">
        <div class="pm-wrap">
          <h2 style="margin:0 0 12px;">
            포스트 관리 <span class="pm-pill">Sheet DB + Drive HTML</span>
          </h2>

          <div id="banner" class="pm-banner"></div>

          <section class="pm-card">
            <div class="pm-row">
              <div class="pm-label">Post 선택</div>
              <select id="postSelect" class="pm-select"></select>

              <button id="btnRefresh" class="pm-btn">목록 새로고침</button>
              <button id="btnLoad" class="pm-btn primary">불러오기</button>
            </div>

            <div class="pm-row" style="margin-top:10px;">
              <div class="pm-label">ID</div>
              <input id="id" class="pm-input" type="text" placeholder="예: NM_20260121_01" disabled />
              <button id="btnSetFromSelect" class="pm-btn">선택값을 ID에 반영</button>
            </div>

            <div class="pm-row" style="margin-top:10px;">
              <div class="pm-label">분류</div>
              <select id="category" class="pm-select">
                <option value="">분류 선택...</option>
                <option value="monthly_news">주요 사건, 이슈, 뉴스 월별 총정리</option>
                <option value="timeline_kr_cn_jp">한국사+중국사+일본사 연표</option>
                <option value="genealogy_series">가계도시리즈</option>
                <option value="etc">기타</option>
                <option value="manual">수동입력</option>
              </select>
              <button id="btnRegenId" class="pm-btn">ID 새로 생성</button>
              <div class="pm-muted pm-small">※ 분류 선택 시 ID 자동생성. “수동입력”만 직접 입력 가능.</div>
            </div>

            <div class="pm-row" style="margin-top:10px;">
              <div class="pm-label">템플릿(Drive)</div>
              <select id="templateSelect" class="pm-select" style="min-width:280px;"></select>

              <button id="btnApplyTemplate" class="pm-btn">템플릿 적용(새로)</button>
              <button id="btnRewrapTemplate" class="pm-btn">래퍼 재적용(본문 유지)</button>

              <span class="pm-muted pm-small">
                ※ 템플릿은 Drive의 매니페스트(JSON) + 섹션(HTML 조각)을 조립합니다.
              </span>
            </div>

            <div id="status" class="pm-status pm-muted">준비됨</div>

            <details style="margin-top:10px;">
              <summary class="pm-muted" style="cursor:pointer; font-weight:800;">디버그(마지막 응답)</summary>
              <pre id="debug" style="margin:10px 0 0; padding:10px; border:1px solid rgba(15,23,42,0.14); border-radius:12px; background:rgba(15,23,42,0.03); overflow:auto; max-height:220px; font-size:12px;"></pre>
            </details>

            <div class="pm-meta">
              <div class="pm-muted">Drive fileId</div><div id="driveFileId" class="pm-muted">-</div>
              <div class="pm-muted">Drive url</div><div id="driveUrl" class="pm-muted">-</div>
              <div class="pm-muted">Updated</div><div id="updatedAt" class="pm-muted">-</div>
            </div>

            <div class="pm-row" style="margin-top:10px;">
              <a id="openDriveLink" class="pm-link" href="#" target="_blank" style="display:none;">Drive 파일 열기</a>
            </div>
          </section>

          <section class="pm-card">
            <div class="pm-row">
              <div class="pm-label">Title</div>
              <input id="title" class="pm-input pm-title" type="text" placeholder="글 제목" />
              <div class="pm-muted" id="charCount">0 chars</div>
            </div>

            <div style="margin-top:10px;">
              <div class="pm-label" style="margin-bottom:6px;">HTML(최종본)</div>
              <textarea id="html" class="pm-textarea" placeholder="여기에 최종 HTML이 생성됩니다. (디버그/직접편집 가능)"></textarea>
            </div>

            <div style="margin-top:10px;">
              <div class="pm-label" style="margin-bottom:6px;">동적 입력(템플릿 슬롯/토큰)</div>
              <p class="pm-muted pm-small pm-dyn-help" id="dynHelp">
                ※ 템플릿에서 SLOT(예: BODY_1/2/3) 또는 토큰(예: {{THUMB_URL}})을 감지해 입력칸이 자동 생성됩니다.
              </p>

              <!-- SLOT(TEXTAREA) -->
              <div id="slotFields" class="pm-dyn-grid"></div>

              <div class="pm-hr"></div>

              <!-- Token(INPUT) -->
              <div id="tokenFields" class="pm-dyn-grid"></div>
            </div>

            <div class="pm-row" style="margin-top:12px;">
              <button id="btnDriveUpsert" class="pm-btn">Drive로 저장/업데이트</button>
              <button id="btnDriveRead" class="pm-btn">Drive에서 불러오기</button>
              <button id="btnClear" class="pm-btn danger">편집창 비우기</button>
            </div>

            <div class="pm-row" style="margin-top:12px;">
              <div class="pm-label">Blogger</div>
              <label class="pm-muted" style="display:flex; gap:6px; align-items:center;">
                <input id="bloggerPublish" type="checkbox" />
                발행(publish)
              </label>
              <button id="btnBloggerUpsert" class="pm-btn">블로그 업로드/수정</button>
              <button id="btnBloggerRead" class="pm-btn">블로그에서 불러오기</button>
              <a id="openBloggerLink" class="pm-link" href="#" target="_blank" style="display:none;">Blogger 글 열기</a>
              <span id="bloggerMeta" class="pm-muted pm-small"></span>
            </div>

            <div class="pm-row" style="margin-top:10px;">
              <div class="pm-label">라벨</div>

              <input
                id="bloggerLabels"
                class="pm-input"
                type="text"
                placeholder="예: 주요 사건,2026,정치 (콤마로 구분)"
              />

              <select id="bloggerLabelsAction" class="pm-select" style="min-width:180px;">
                <option value="replace">덮어쓰기</option>
                <option value="add">추가</option>
                <option value="remove">제거</option>
              </select>

              <button id="btnBloggerLabels" class="pm-btn">라벨 적용</button>

              <button id="btnBloggerRevert" class="pm-btn danger">초안으로 되돌리기</button>

              <span class="pm-muted pm-small">※ “초안으로 되돌리기”는 발행/예약 글을 draft로 되돌립니다.</span>
            </div>

          </section>
        </div>
      </main>
    </div>
  </div>

  <!-- ✅ 반드시 포함해야 하는 공통 스크립트 유지 -->
  <script src="./admin-common.js"></script>

<script>
/** =========================
 * ✅ admin-common.js: 헤더/메뉴 슬롯 유지
 * ========================= */
(function renderShellOnce(){
  try{
    if (window.AdminCommon && typeof window.AdminCommon.renderShell === "function"){
      window.AdminCommon.renderShell({
        headerSlotId: "admin-header-slot",
        menuSlotId: "admin-menu-slot",
        activeMenu: "post_manage"
      });
    }
  }catch(_){}
})();

(() => {
  const $ = (id) => document.getElementById(id);
  let current = null;

  // ✅ 고정: Apps Script 주소
  const API_BASE =
    "https://script.google.com/macros/s/AKfycbzj5LUEUKMyQqJfVsVlftO1f4CTYb3NhAQMT2QL6VADBlnjleAXLtBVVhuVHOfwkhQYqQ/exec";

  // 섹션 HTML 캐시(같은 섹션을 여러 번 조립할 때 API 호출 최소화)
  const sectionCache = new Map(); // key: sectionName, value: html

  // 현재 템플릿 분석 결과
  const templateState = {
    templateId: "",
    manifest: null,
    slots: [],   // ["BODY_1", "BODY_2", ...]
    tokens: []   // ["THUMB_URL", "CANONICAL_URL", ...] (필요한 것만 노출)
  };

  function setStatus(msg, ok=true){
    const el = $("status");
    el.textContent = msg;
    el.className = "pm-status " + (ok ? "ok" : "err");
  }

  function showBanner(msg){
    const b = $("banner");
    b.textContent = msg;
    b.style.display = "block";
  }

  function hideBanner(){
    const b = $("banner");
    b.textContent = "";
    b.style.display = "none";
  }

  function setDebug(obj){
    const el = $("debug");
    if (!el) return;
    try{ el.textContent = (typeof obj === 'string') ? obj : JSON.stringify(obj, null, 2); }
    catch(e){ el.textContent = String(obj); }
  }

  function setMeta(post){
    $("driveFileId").textContent = post.drive_file_id || "-";
    $("driveUrl").textContent = post.drive_url || "-";
    $("updatedAt").textContent = post.updated_at || "-";

    const link = $("openDriveLink");
    if (post.drive_url){
      link.href = post.drive_url;
      link.style.display = "inline";
    } else {
      link.style.display = "none";
    }
  }

  function setBloggerMeta(info){
    const meta = $("bloggerMeta");
    const link = $("openBloggerLink");
    if (meta){
      meta.textContent = info
        ? (info.status ? `status: ${info.status}` : '') + (info.post_id ? `  postId: ${info.post_id}` : '')
        : '';
    }
    if (link){
      if (info && info.url){
        link.href = info.url;
        link.style.display = 'inline';
      }else{
        link.style.display = 'none';
      }
    }
  }

  function syncCharCount(){
    $("charCount").textContent = ($("html").value || "").length + " chars";
  }
  $("html").addEventListener("input", syncCharCount);

  function buildUrl(mode, paramsObj){
    const params = new URLSearchParams();
    params.set("mode", mode);
    params.set("_ts", String(Date.now()));

    if (paramsObj && typeof paramsObj === "object"){
      for (const [k,v] of Object.entries(paramsObj)){
        if (v === undefined || v === null) continue;
        params.set(k, String(v));
      }
    }
    return `${API_BASE}?${params.toString()}`;
  }

  // ===== meta/body parsing (기존 글 수정용) =====
  function readTemplateMeta_(html){
    const get = (key) => {
      const re = new RegExp(`<!--\\s*${key}\\s*:\\s*([^>]+?)\\s*-->`, "i");
      const m = String(html||"").match(re);
      return m ? m[1].trim() : "";
    };
    return {
      template_id: get("template_id"),
      template_ver: get("template_ver"),
    };
  }

  // ✅ 다중 BODY 마커도 지원:
  //   <!-- BODY_START:BODY_1 --> ... <!-- BODY_END:BODY_1 -->
  //   <!-- BODY_START --> ... <!-- BODY_END -->  (기본 BODY)
  function extractBodies_(html){
    const t = String(html || "");
    const out = {};

    // 1) named marker
    const reStart = /<!--\s*BODY_START(?::([A-Z0-9_]+))?\s*-->/ig;
    let m;
    while ((m = reStart.exec(t)) !== null){
      const name = (m[1] || "BODY").trim();
      const startIdx = reStart.lastIndex;

      // end marker
      const endMark = name === "BODY"
        ? /<!--\s*BODY_END\s*-->/ig
        : new RegExp(`<!--\\s*BODY_END\\s*:\\s*${escapeRegExp(name)}\\s*-->`, "ig");

      endMark.lastIndex = startIdx;
      const em = endMark.exec(t);
      if (!em) continue;

      const endIdx = em.index;
      out[name] = t.slice(startIdx, endIdx).trim();
      // continue after end marker
      reStart.lastIndex = endMark.lastIndex;
    }

    // 2) fallback: 마커가 전혀 없으면 전체를 BODY로 추측
    if (Object.keys(out).length === 0){
      out["BODY"] = t.trim();
    }

    return out;
  }

  // ===== API =====
  async function apiGet(mode, paramsObj){
    const url = buildUrl(mode, paramsObj);
    const res = await fetch(url, { method:"GET", cache:"no-store", credentials:"omit" });
    const text = await res.text().catch(()=> "");
    if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}\n${text.slice(0,500)}`);
    try { return JSON.parse(text); }
    catch { throw new Error("JSON_PARSE_FAILED\n" + text.slice(0,500)); }
  }

  async function apiPost(mode, bodyObj){
    const url = `${API_BASE}?_ts=${Date.now()}`;
    const body = new URLSearchParams();
    body.set("mode", String(mode || ""));
    if (bodyObj && typeof bodyObj === "object"){
      for (const [k,v] of Object.entries(bodyObj)){
        if (v === undefined || v === null) continue;
        body.set(k, String(v));
      }
    }
    const res = await fetch(url, { method:"POST", body, cache:"no-store", credentials:"omit" });
    const text = await res.text().catch(()=> "");
    let data = null;
    try { data = JSON.parse(text); } catch(_){}
    if (!res.ok) throw new Error(`HTTP ${res.status}: ${text.slice(0,300)}`);
    if (!data)   throw new Error(`JSON 아님: ${text.slice(0,300)}`);
    return data;
  }

  // ===== Drive Template/Section helpers =====
  async function listTemplates_(){
    const res = await apiGet("listTemplates");
    if (!res || !res.ok) throw new Error(res?.message || "LIST_TEMPLATES_FAILED");
    return res.items || [];
  }

  async function getTemplateManifest_(templateId){
    const res = await apiGet("getTemplate", { template_id: templateId });
    if (!res || !res.ok) throw new Error(res?.message || "GET_TEMPLATE_FAILED");

    const txt = String(res.json || "").trim();
    if (!txt) throw new Error("TEMPLATE_JSON_EMPTY");

    let manifest = null;
    try{ manifest = JSON.parse(txt); }
    catch(e){
      throw new Error("TEMPLATE_JSON_PARSE_FAILED: " + (e?.message || e));
    }
    return manifest;
  }

  async function getSectionHtml_(name){
    const key = String(name || "").trim();
    if (!key) return "";
    if (sectionCache.has(key)) return sectionCache.get(key);

    const res = await apiGet("getSection", { name: key });
    if (!res || !res.ok) throw new Error(res?.message || ("GET_SECTION_FAILED: " + key));

    const html = String(res.html || "");
    sectionCache.set(key, html);
    return html;
  }

  function escapeRegExp(s){
    return String(s||"").replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  function replaceTokens_(html, vars){
    let out = String(html || "");
    if (!vars || typeof vars !== "object") return out;

    for (const [k,v] of Object.entries(vars)){
      const key = String(k || "").trim();
      if (!key) continue;
      const re = new RegExp(`{{\\s*${escapeRegExp(key)}\\s*}}`, "g");
      out = out.replace(re, String(v ?? ""));
    }
    return out;
  }

  function collectSlotsFromManifest_(manifest){
    const slots = [];
    const seen = new Set();

    const sections = Array.isArray(manifest?.sections) ? manifest.sections : [];
    for (const sec of sections){
      const slot = (sec && typeof sec === "object" && sec.vars && sec.vars.SLOT)
        ? String(sec.vars.SLOT).trim()
        : "";

      if (slot && !seen.has(slot)){
        seen.add(slot);
        slots.push(slot);
      }
    }

    // SLOT 기반이 하나도 없으면: 기존 방식(BODY 1개)로
    if (slots.length === 0) slots.push("BODY");
    return slots;
  }

  async function collectTokensFromTemplate_(manifest, slotNames){
    // 템플릿 섹션들을 읽어 토큰을 찾아냄 (지원 토큰만 입력칸 생성)
    const supported = new Set([
      "THUMB_URL",
      "CANONICAL_URL",
      "YEAR",
      "MONTH"
    ]);

    const reserved = new Set(["TITLE","NAV","FOOTER","BODY"]);
    (slotNames || []).forEach(s=>reserved.add(String(s)));

    const found = new Set();
    const sections = Array.isArray(manifest?.sections) ? manifest.sections : [];

    for (const sec of sections){
      const name =
        (typeof sec === "string") ? sec.trim() :
        (sec && typeof sec === "object") ? String(sec.name || "").trim() : "";

      if (!name) continue;

      let html = "";
      try{ html = await getSectionHtml_(name); }catch(_){ html = ""; }
      const re = /{{\s*([A-Z0-9_]+)\s*}}/g;
      let m;
      while ((m = re.exec(String(html))) !== null){
        const token = String(m[1] || "").trim();
        if (!token) continue;
        if (reserved.has(token)) continue;
        if (supported.has(token)) found.add(token);
      }
    }

    return Array.from(found);
  }

  function renderDynamicFields_(slotNames, tokenNames){
    const slotBox = $("slotFields");
    const tokBox  = $("tokenFields");
    slotBox.innerHTML = "";
    tokBox.innerHTML = "";

    // SLOT(TEXTAREA)
    for (const slot of (slotNames || [])){
      const wrap = document.createElement("div");
      wrap.className = "pm-dyn-item";
      wrap.innerHTML = `
        <div class="pm-dyn-key">${escapeHtml(slot)}</div>
        <textarea class="pm-textarea pm-dyn-textarea" data-slot="${escapeHtml(slot)}"
          placeholder="템플릿 SLOT: ${escapeHtml(slot)}"></textarea>
      `;
      slotBox.appendChild(wrap);
    }

    // Token(INPUT)
    if (!tokenNames || tokenNames.length === 0){
      const empty = document.createElement("div");
      empty.className = "pm-muted pm-small";
      empty.textContent = "추가 토큰(THUMB_URL, CANONICAL_URL, YEAR, MONTH)이 감지되지 않았습니다.";
      tokBox.appendChild(empty);
      return;
    }

    for (const tok of tokenNames){
      const wrap = document.createElement("div");
      wrap.className = "pm-dyn-item";
      wrap.innerHTML = `
        <div class="pm-dyn-key">${escapeHtml(tok)}</div>
        <input class="pm-input" data-token="${escapeHtml(tok)}" style="min-width:0; width:100%;"
          placeholder="${tokenPlaceholder_(tok)}" />
      `;
      tokBox.appendChild(wrap);
    }
  }

  function tokenPlaceholder_(tok){
    switch(String(tok||"")){
      case "THUMB_URL": return "예: https://... (썸네일 이미지 URL)";
      case "CANONICAL_URL": return "예: https://www.cheesehistory.com/... (정식 URL)";
      case "YEAR": return "예: 2026";
      case "MONTH": return "예: 01";
      default: return "";
    }
  }

  function getSlotValues_(){
    const out = {};
    document.querySelectorAll("[data-slot]").forEach(el=>{
      const k = el.getAttribute("data-slot");
      if (!k) return;
      out[k] = (el.value || "");
    });
    return out;
  }

  function setSlotValues_(map){
    const m = map || {};
    document.querySelectorAll("[data-slot]").forEach(el=>{
      const k = el.getAttribute("data-slot");
      if (!k) return;
      el.value = (m[k] !== undefined && m[k] !== null) ? String(m[k]) : "";
    });
  }

  function getTokenValues_(){
    const out = {};
    document.querySelectorAll("[data-token]").forEach(el=>{
      const k = el.getAttribute("data-token");
      if (!k) return;
      out[k] = (el.value || "");
    });
    return out;
  }

  function setTokenValues_(map){
    const m = map || {};
    document.querySelectorAll("[data-token]").forEach(el=>{
      const k = el.getAttribute("data-token");
      if (!k) return;
      el.value = (m[k] !== undefined && m[k] !== null) ? String(m[k]) : "";
    });
  }

  function buildVarsForAssemble_(){
    const title = $("title").value.trim();

    const slotVals  = getSlotValues_();
    const tokenVals = getTokenValues_();

    // ✅ 최소 호환: TITLE / BODY는 자주 쓰는 키라 항상 넣어줌
    const vars = {
      TITLE: title,
      title: title, // 혹시 소문자 템플릿이 있을 때
      NAV: "",
      FOOTER: "",
      nav: "",
      footer: "",
      ...slotVals,
      ...tokenVals
    };

    // “BODY” 슬롯이 없는데도 템플릿이 {{BODY}}를 쓰는 경우 대비
    if (vars.BODY === undefined) vars.BODY = "";

    return vars;
  }

  async function analyzeAndRenderTemplate_(tplId){
    templateState.templateId = tplId || "";
    templateState.manifest = null;
    templateState.slots = [];
    templateState.tokens = [];

    if (!tplId){
      renderDynamicFields_(["BODY"], []); // 기본
      return;
    }

    try{
      const manifest = await getTemplateManifest_(tplId);
      templateState.manifest = manifest;

      const slotNames = collectSlotsFromManifest_(manifest);
      const tokenNames = await collectTokensFromTemplate_(manifest, slotNames);

      templateState.slots = slotNames;
      templateState.tokens = tokenNames;

      // 기존 입력값은 최대한 보존 (키가 같은 것만 유지)
      const prevSlots = getSlotValues_();
      const prevToks  = getTokenValues_();

      renderDynamicFields_(slotNames, tokenNames);

      setSlotValues_(prevSlots);
      setTokenValues_(prevToks);

    }catch(e){
      // 템플릿 JSON 파싱/로드 실패 시에도 기본 BODY 1개는 남겨둠
      renderDynamicFields_(["BODY"], []);
      setStatus("템플릿 분석 실패: " + e.message, false);
      setDebug(String(e && e.stack ? e.stack : e));
    }
  }

async function assembleHtmlFromTemplate_(templateId, vars){
  const manifest = await getTemplateManifest_(templateId);

  // meta
  const tid = String(manifest.template_id || manifest.id || templateId).trim();
  const tver = String(manifest.template_ver || manifest.ver || "").trim();

  const sections = Array.isArray(manifest.sections) ? manifest.sections : [];
  if (!sections.length) throw new Error("TEMPLATE_SECTIONS_EMPTY");

  const parts = [];

  for (const sec of sections){
    const secName =
      (typeof sec === "string") ? sec.trim() :
      (sec && typeof sec === "object") ? String(sec.name || "").trim() : "";

    if (!secName) continue;

    let secHtml = await getSectionHtml_(secName);

    // 섹션별 vars (SLOT 포함 가능)
    const secVarsRaw = (sec && typeof sec === "object" && sec.vars && typeof sec.vars === "object")
      ? sec.vars
      : {};

    // 1) SLOT 치환 + BODY 마커 충돌 방지(섹션별 SLOT명으로 이름 붙이기)
    const slotName = (secVarsRaw && secVarsRaw.SLOT) ? String(secVarsRaw.SLOT).trim() : "";

    if (slotName){
      // {{BODY}}가 있으면 SLOT의 값(vars[slotName])으로 치환
      const slotVal = (vars && (vars[slotName] ?? vars[String(slotName).toUpperCase()])) ?? "";
      secHtml = secHtml.replace(/{{\s*BODY\s*}}/g, String(slotVal));

      // 기본 BODY 마커를 SLOT명으로 이름 붙여서 저장
      secHtml = secHtml
        .replace(/<!--\s*BODY_START\s*-->/gi, `<!-- BODY_START:${slotName} -->`)
        .replace(/<!--\s*BODY_END\s*-->/gi, `<!-- BODY_END:${slotName} -->`)
        .replace(/<!--\s*BODY_START\s*:\s*BODY\s*-->/gi, `<!-- BODY_START:${slotName} -->`)
        .replace(/<!--\s*BODY_END\s*:\s*BODY\s*-->/gi, `<!-- BODY_END:${slotName} -->`);
    }

    // 2) 섹션 vars도 함께 토큰 치환 대상으로 사용
    const secVars = { ...secVarsRaw };

    // 3) 토큰 치환 (전역 vars + 섹션 vars)
    secHtml = replaceTokens_(secHtml, { ...vars, ...secVars });

    parts.push(secHtml);
  }

  let assembled = parts.join("\n");

  const metaHeader =
    `<!-- template_id: ${tid} -->\n` +
    (tver ? `<!-- template_ver: ${tver} -->\n` : "");

  assembled = metaHeader + assembled;

  return { html: assembled, manifest };
}


  async function initTemplateSelect_(){
    const sel = $("templateSelect");
    sel.innerHTML = "";

    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "템플릿 선택...";
    sel.appendChild(opt0);

    try{
      setStatus("템플릿 목록 불러오는 중(Drive)...", true);
      const items = await listTemplates_();

      for (const it of items){
        const id = String(it.id || it.template_id || it.name || "").replace(/\.json$/i, "").trim();
        if (!id) continue;

        const opt = document.createElement("option");
        opt.value = id;
        opt.textContent = id;
        sel.appendChild(opt);
      }

      setStatus(`템플릿 ${items.length}개 로드됨`, true);
    }catch(e){
      setStatus("템플릿 목록 불러오기 실패: " + e.message, false);
      showBanner(String(e && e.stack ? e.stack : e));
    }
  }

  // ===== UI actions =====
  async function applyTemplateNew(){
    const tplId = $("templateSelect").value;
    if (!tplId) return setStatus("템플릿을 먼저 선택하세요.", false);

    try{
      hideBanner();
      setStatus("템플릿 적용(새로) 중...", true);

      await analyzeAndRenderTemplate_(tplId);

      // 새로 시작: SLOT 입력값 비우기 (토큰은 유지)
      setSlotValues_({});

      const out = await assembleHtmlFromTemplate_(tplId, buildVarsForAssemble_());

      $("html").value = out.html;
      syncCharCount();
      setStatus("템플릿 적용 완료(새로). SLOT 입력칸을 채운 뒤 저장하세요.", true);

    }catch(e){
      setStatus("템플릿 적용 오류: " + e.message, false);
      setDebug(String(e && e.stack ? e.stack : e));
    }
  }

  async function rewrapTemplateKeepBody(){
    const tplId = $("templateSelect").value;
    if (!tplId) return setStatus("템플릿을 먼저 선택하세요.", false);

    try{
      hideBanner();
      setStatus("래퍼 재적용(본문 유지) 중...", true);

      const out = await assembleHtmlFromTemplate_(tplId, buildVarsForAssemble_());

      $("html").value = out.html;
      syncCharCount();
      setStatus("래퍼 재적용 완료(본문 유지).", true);

    }catch(e){
      setStatus("래퍼 재적용 오류: " + e.message, false);
      setDebug(String(e && e.stack ? e.stack : e));
    }
  }

  // ===== Post list/load =====
  function setFromSelect(){
    const v = $("postSelect").value;
    if (v) $("id").value = v;
  }

  function getTargetId(){
    const fromSelect = $("postSelect").value;
    const fromInput  = $("id").value.trim();
    return fromInput || fromSelect || "";
  }

  async function refreshList(selectId){
    try{
      hideBanner();
      setStatus("목록 불러오는 중...", true);
      const res = await apiGet("listPosts");
      if (!res || !res.ok) return setStatus("목록 불러오기 실패: " + (res?.message||""), false);

      const sel = $("postSelect");
      sel.innerHTML = "";
      const items = res.items || [];

      const opt0 = document.createElement("option");
      opt0.value = "";
      opt0.textContent = "선택...";
      sel.appendChild(opt0);

      for (const it of items){
        const opt = document.createElement("option");
        opt.value = it.id;
        opt.textContent = it.id + (it.title ? ` — ${it.title}` : "");
        sel.appendChild(opt);
      }

      if (selectId){
        sel.value = selectId;
        $("id").value = selectId;
      }

      setStatus(`목록 ${items.length}건`, true);
    }catch(e){
      setStatus("목록 불러오기 오류: " + e.message, false);
      showBanner(String(e && e.stack ? e.stack : e));
    }
  }

  async function loadPost(){
    const id = getTargetId();
    if (!id) return setStatus("id를 선택하거나 입력하세요.", false);

    try{
      hideBanner();
      setStatus(`불러오는 중: ${id}`, true);
      const res = await apiGet("getPost", { id });

      if (!res || !res.ok) return setStatus("불러오기 실패: " + (res?.message||""), false);

      current = res.post;

      $("id").value = current.id;
      $("title").value = current.title || "";
      $("html").value = current.html || "";

      // template_id 자동 선택 (기존 글 수정용)
      const meta = readTemplateMeta_(current.html || "");
      if (meta.template_id && $("templateSelect")) {
        $("templateSelect").value = meta.template_id;
        await analyzeAndRenderTemplate_(meta.template_id);
      } else {
        await analyzeAndRenderTemplate_($("templateSelect").value || "");
      }

      // body 추출 (단일/다중)
      const bodies = extractBodies_(current.html || "");
      setSlotValues_(bodies);

      syncCharCount();
      setMeta(current);
      setBloggerMeta(null);

      setStatus("불러오기 완료", true);
    }catch(e){
      setStatus("불러오기 오류: " + e.message, false);
      setDebug(String(e && e.stack ? e.stack : e));
    }
  }

  // ===== Drive HTML upsert/read =====
  async function exportToDrive(){
    const id = getTargetId();
    if (!id) return setStatus("id가 필요합니다.", false);

    try{
      hideBanner();

      const tplId = $("templateSelect").value;
      if (tplId){
        setStatus("저장 전 최종 HTML 생성(템플릿 조립) 중...", true);
        const out = await assembleHtmlFromTemplate_(tplId, buildVarsForAssemble_());
        $("html").value = out.html;
        syncCharCount();
      }

      const payload = {
        id,
        title: $("title").value.trim(),
        html: $("html").value
      };

      setStatus("Drive 저장/업데이트 중...", true);
      const res = await apiPost("driveUpsert", payload);
      setDebug(res);

      if (!res || !res.ok) return setStatus("Drive 저장 실패: " + (res?.message||""), false);

      setStatus(`Drive 저장 완료: ${res.file?.name || ""}`, true);
      await refreshList(id);
      await loadPost();

    }catch(e){
      setStatus("Drive 저장 오류: " + e.message, false);
      setDebug(String(e && e.stack ? e.stack : e));
    }
  }

  async function importFromDrive(){
    const id = getTargetId();
    if (!id) return setStatus("id가 필요합니다.", false);

    try{
      hideBanner();
      setStatus("Drive에서 불러오는 중...", true);
      const res = await apiGet("driveReadById", { id });

      if (!res || !res.ok) return setStatus("Drive 불러오기 실패: " + (res?.message||""), false);

      const html = res.html || "";
      $("html").value = html;

      // Drive HTML 기준으로 본문/템플릿 자동 복원
      const meta = readTemplateMeta_(html);
      if (meta.template_id) {
        $("templateSelect").value = meta.template_id;
        await analyzeAndRenderTemplate_(meta.template_id);
      } else {
        await analyzeAndRenderTemplate_($("templateSelect").value || "");
      }

      // 다중 body 추출
      setSlotValues_(extractBodies_(html));

      syncCharCount();
      setStatus("Drive 불러오기 완료", true);

    }catch(e){
      setStatus("Drive 불러오기 오류: " + e.message, false);
      setDebug(String(e && e.stack ? e.stack : e));
    }
  }

  // ===== Blogger =====
  async function exportToBlogger(){
    const id = getTargetId();
    if (!id) return setStatus("id가 필요합니다.", false);

    const payload = {
      id,
      title: $("title").value.trim(),
      html: $("html").value,
      publish: $("bloggerPublish").checked ? "true" : "false"
    };

    try{
      hideBanner();
      setStatus("Blogger 업로드/수정 중...", true);
      const res = await apiPost("bloggerUpsert", payload);
      setDebug(res);

      if (!res || !res.ok) return setStatus("Blogger 업로드 실패: " + (res?.message||""), false);

      setBloggerMeta({ url: res.url, post_id: res.post_id, status: res.status });
      setStatus(`Blogger ${res.status === 'published' ? '발행' : '초안'} 완료`, true);
    }catch(e){
      setStatus("Blogger 업로드 오류: " + e.message, false);
      setDebug(String(e && e.stack ? e.stack : e));
    }
  }

  async function importFromBlogger(){
    const id = getTargetId();
    if (!id) return setStatus("id가 필요합니다.", false);

    try{
      hideBanner();
      setStatus("Blogger에서 불러오는 중...", true);
      const res = await apiGet("bloggerRead", { id });
      setDebug(res);

      if (!res || !res.ok) return setStatus("Blogger 불러오기 실패: " + (res?.message||""), false);

      $("title").value = res.title || $("title").value;
      $("html").value = res.html || "";
      syncCharCount();

      const html = $("html").value || "";
      const meta = readTemplateMeta_(html);
      if (meta.template_id) {
        $("templateSelect").value = meta.template_id;
        await analyzeAndRenderTemplate_(meta.template_id);
      } else {
        await analyzeAndRenderTemplate_($("templateSelect").value || "");
      }

      setSlotValues_(extractBodies_(html));

      setBloggerMeta({ url: res.url, post_id: res.post_id, status: "loaded" });
      setStatus("Blogger 불러오기 완료", true);
    }catch(e){
      setStatus("Blogger 불러오기 오류: " + e.message, false);
      setDebug(String(e && e.stack ? e.stack : e));
    }
  }

  async function patchBloggerLabels(){
    const id = getTargetId();
    if (!id) return setStatus("id가 필요합니다.", false);

    const labels = $("bloggerLabels").value.trim(); // "a,b,c"
    const action = $("bloggerLabelsAction").value || "replace";

    try{
      hideBanner();
      setStatus("라벨 적용 중...", true);
      const res = await apiPost("bloggerPatchLabels", { id, labels, action });
      setDebug(res);

      if (!res || !res.ok) return setStatus("라벨 적용 실패: " + (res?.message||""), false);

      setStatus(`라벨 적용 완료 (${(res.labels||[]).length}개)`, true);
      if (res.url) setBloggerMeta({ url: res.url, post_id: res.post_id, status: "labels_updated" });

    }catch(e){
      setStatus("라벨 적용 오류: " + e.message, false);
      setDebug(String(e && e.stack ? e.stack : e));
    }
  }

  async function revertBloggerToDraft(){
    const id = getTargetId();
    if (!id) return setStatus("id가 필요합니다.", false);

    try{
      hideBanner();
      setStatus("초안으로 되돌리는 중...", true);
      const res = await apiPost("bloggerRevert", { id });
      setDebug(res);

      if (!res || !res.ok) return setStatus("초안 되돌리기 실패: " + (res?.message||""), false);

      setBloggerMeta({ url: res.url, post_id: res.post_id, status: "draft" });
      setStatus("초안으로 되돌리기 완료", true);

    }catch(e){
      setStatus("초안 되돌리기 오류: " + e.message, false);
      setDebug(String(e && e.stack ? e.stack : e));
    }
  }

  function clearEditor(){
    $("title").value = "";
    $("html").value = "";
    setSlotValues_({});
    setTokenValues_({});
    syncCharCount();
    setStatus("편집창을 비웠습니다.", true);
  }

  /* =========================
     ✅ ID 자동생성(분류 기반)
  ========================= */

  function mapCategoryToPrefix(cat){
    const m = {
      monthly_news: "NM",
      timeline_kr_cn_jp: "TL",
      genealogy_series: "GN",
      etc: "ETC",
    };
    return m[cat] || "POST";
  }

  function yyyymmddNow(){
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}${m}${day}`;
  }

  async function regenId(){
    const cat = $("category").value;

    if (!cat) {
      setStatus("분류를 먼저 선택하세요.", false);
      return;
    }

    if (cat === "manual"){
      setStatus("수동입력 분류입니다. ID를 직접 입력하세요.", true);
      $("id").disabled = false;
      $("id").focus();
      return;
    }

    const prefix = mapCategoryToPrefix(cat);
    const dateToken = yyyymmddNow();
    const base = `${prefix}_${dateToken}_`;

    try{
      setStatus("ID 생성 중...", true);

      const res = await apiGet("listPosts");
      if (!res || !res.ok) throw new Error(res?.message || "LIST_FAILED");

      let maxSeq = 0;
      for (const it of (res.items || [])){
        const id = String(it.id || "");
        if (!id.startsWith(base)) continue;
        const tail = id.slice(base.length);
        const n = parseInt(tail, 10);
        if (!isNaN(n)) maxSeq = Math.max(maxSeq, n);
      }

      const nextSeq = String(maxSeq + 1).padStart(2, "0");
      $("id").value = `${base}${nextSeq}`;
      $("id").disabled = true;

      setStatus(`ID 생성 완료: ${$("id").value}`, true);
    }catch(e){
      setStatus("ID 생성 오류: " + (e.message || e), false);
      setDebug(String(e && e.stack ? e.stack : e));
    }
  }

  function onCategoryChange(){
    const cat = $("category").value;

    if (cat === "manual"){
      $("id").disabled = false;
      setStatus("수동입력: ID를 직접 입력하세요.", true);
      return;
    }

    $("id").disabled = true;
    if (cat) regenId();
  }

  // templateSelect 변경 시: SLOT/토큰 입력칸 재구성
  $("templateSelect").addEventListener("change", async ()=>{
    const tplId = $("templateSelect").value || "";
    await analyzeAndRenderTemplate_(tplId);
  });

  /* =========================
     버튼 연결
  ========================= */
  $("btnRefresh").addEventListener("click", ()=>refreshList());
  $("btnLoad").addEventListener("click", loadPost);
  $("btnSetFromSelect").addEventListener("click", setFromSelect);

  $("btnApplyTemplate").addEventListener("click", applyTemplateNew);
  $("btnRewrapTemplate").addEventListener("click", rewrapTemplateKeepBody);

  $("btnDriveUpsert").addEventListener("click", exportToDrive);
  $("btnDriveRead").addEventListener("click", importFromDrive);
  $("btnClear").addEventListener("click", clearEditor);

  $("btnBloggerUpsert").addEventListener("click", exportToBlogger);
  $("btnBloggerRead").addEventListener("click", importFromBlogger);

  $("btnBloggerLabels").addEventListener("click", patchBloggerLabels);
  $("btnBloggerRevert").addEventListener("click", revertBloggerToDraft);

  $("btnRegenId").addEventListener("click", regenId);
  $("category").addEventListener("change", onCategoryChange);

  // init
  setDebug("");
  renderDynamicFields_(["BODY"], []); // 템플릿 선택 전 기본
  refreshList();
  initTemplateSelect_();
})();

function escapeHtml(s){
  return String(s||"").replace(/[&<>"']/g, (m)=>({
    "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
  }[m]));
}
</script>

</body>
</html>
