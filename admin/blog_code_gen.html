<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>블로그 코드 생성</title>

  <!-- ✅ 공통 CSS -->
  <link rel="stylesheet" href="./admin.css" />

  <style>
    /* ===== page local styles ===== */
    .bcg-wrap{ padding:14px; }

    .bcg-hero{
      display:flex; align-items:flex-start; justify-content:space-between; gap:12px;
      margin-bottom:12px;
    }
    .bcg-title{
      margin:0;
      font-weight:950;
      letter-spacing:-0.2px;
      font-size:18px;
    }
    .bcg-sub{
      margin:6px 0 0;
      color:rgba(15,23,42,.72);
      line-height:1.45;
      font-size:13px;
    }

    .bcg-actions{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }

    .bcg-card{
      background:#fff;
      border:1px solid rgba(15,23,42,0.14);
      border-radius:16px;
      padding:14px;
      box-shadow:0 10px 24px rgba(15,23,42,0.06);
      margin-bottom:12px;
    }

    .bcg-row{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      margin-top:10px;
    }
    .bcg-row:first-child{ margin-top:0; }

    .bcg-label{
      font-weight:900;
      font-size:12px;
      color:rgba(15,23,42,.78);
    }

    .bcg-input, .bcg-select, .bcg-textarea{
      padding:10px 12px;
      border:1px solid rgba(15,23,42,0.18);
      border-radius:12px;
      outline:none;
      background:#fff;
      font-size:13px;
    }
    .bcg-input{ min-width:240px; flex:1; }
    .bcg-select{ min-width:110px; }
    .bcg-textarea{
      width:100%;
      min-height:160px;
      resize:vertical;
      line-height:1.55;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", Arial, "맑은 고딕", sans-serif;
    }

    .bcg-output{
      width:100%;
      min-height:160px;
      resize:vertical;
      padding:10px 12px;
      border:1px dashed rgba(15,23,42,0.26);
      border-radius:12px;
      background:rgba(15,23,42,0.02);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12px;
      line-height:1.55;
      white-space:pre;
    }

    .bcg-preview{
      width:100%;
      border:1px solid rgba(15,23,42,0.14);
      border-radius:12px;
      padding:12px;
      background:#fff;
      box-shadow:0 8px 18px rgba(15,23,42,0.06);
      min-height:64px;
      overflow:auto;
    }
    .bcg-preview h1, .bcg-preview h2, .bcg-preview h3{
      margin:0 0 10px;
      line-height:1.25;
    }
    .bcg-preview p{ margin:0 0 10px; line-height:1.6; }
    .bcg-preview p:last-child{ margin-bottom:0; }
    .bcg-preview-empty{
      color:rgba(15,23,42,.55);
      font-size:12px;
    }

    .bcg-btn{
      border:1px solid rgba(15,23,42,0.16);
      background:#fff;
      border-radius:14px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:900;
      font-size:13px;
      display:inline-flex;
      gap:8px;
      align-items:center;
      transition:transform .06s ease, box-shadow .18s ease, background .18s ease, border-color .18s ease;
      box-shadow:0 8px 18px rgba(15,23,42,0.08);
      user-select:none;
    }
    .bcg-btn:active{ transform:translateY(1px); box-shadow:0 5px 12px rgba(15,23,42,0.10); }
    .bcg-btn:hover{ background:rgba(15,23,42,0.02); border-color:rgba(15,23,42,0.22); }

    .bcg-btn--primary{
      border-color:rgba(37,99,235,0.38);
      box-shadow:0 10px 20px rgba(37,99,235,0.14);
    }
    .bcg-btn--primary:hover{ background:rgba(37,99,235,0.06); border-color:rgba(37,99,235,0.55); }

    .bcg-btn--danger{
      border-color:rgba(239,68,68,0.30);
      box-shadow:0 10px 20px rgba(239,68,68,0.10);
    }
    .bcg-btn--danger:hover{ background:rgba(239,68,68,0.06); border-color:rgba(239,68,68,0.48); }

    .bcg-pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(15,23,42,0.14);
      background:#fff;
      font-size:12px;
      color:rgba(15,23,42,.72);
    }

    .bcg-toast{
      position:fixed;
      right:16px;
      bottom:16px;
      z-index:9999;
      max-width:min(420px, calc(100vw - 32px));
      background:rgba(15,23,42,0.92);
      color:#fff;
      border-radius:14px;
      padding:10px 12px;
      box-shadow:0 18px 40px rgba(15,23,42,0.35);
      font-size:13px;
      line-height:1.35;
      transform:translateY(10px);
      opacity:0;
      pointer-events:none;
      transition:opacity .18s ease, transform .18s ease;
    }
    .bcg-toast.show{ opacity:1; transform:translateY(0); }

    .bcg-grid{
      display:grid;
      grid-template-columns:1fr;
      gap:10px;
    }

    .bcg-split{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
    }
    @media (max-width: 980px){
      .bcg-split{ grid-template-columns:1fr; }
    }

    .bcg-muted{
      color:rgba(15,23,42,.62);
      font-size:12px;
    }

    .bcg-sep{
      height:1px;
      background:rgba(15,23,42,0.10);
      margin:12px 0;
    }

    .bcg-mini{
      font-size:12px;
      padding:8px 10px;
      border-radius:12px;
      box-shadow:none;
    }

    .bcg-badge{
      font-weight:950;
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(15,23,42,0.14);
      background:rgba(15,23,42,0.02);
    }

    .bcg-right{ margin-left:auto; }

    .bcg-check{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:12px;
      color:rgba(15,23,42,.72);
      user-select:none;
    }
    .bcg-check input{ width:16px; height:16px; }
.bcg-toolbar{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  align-items:center;
  margin:6px 0 8px;
}
.bcg-pill input[type="color"]{
  width:34px;
  height:20px;
  padding:0;
  border:0;
  background:transparent;
  cursor:pointer;
}
.bcg-pill input[type="color"]::-webkit-color-swatch-wrapper{ padding:0; }
.bcg-pill input[type="color"]::-webkit-color-swatch{
  border:1px solid rgba(15,23,42,0.18);
  border-radius:6px;
}
  
/* ===== table styles (preview) ===== */
.bcg-preview .cheese-table{
  width:100%;
  border-collapse:collapse;
  border:1px solid rgba(15,23,42,0.14);
  border-radius:12px;
  overflow:hidden;
}
.bcg-preview .cheese-table th,
.bcg-preview .cheese-table td{
  border:1px solid rgba(15,23,42,0.14);
  padding:10px;
  vertical-align:top;
  font-size:13px;
  line-height:1.45;
}
.bcg-preview .cheese-table th{
  background:rgba(15,23,42,0.04);
  font-weight:900;
}
.bcg-preview .cheese-table caption{
  caption-side:top;
  text-align:left;
  font-weight:900;
  padding:8px 2px 10px;
  color:rgba(15,23,42,.78);
}

/* ===== modal (table builder) ===== */
.bcg-modal-backdrop{
  position:fixed;
  inset:0;
  background:rgba(15,23,42,0.55);
  display:flex;
  align-items:center;
  justify-content:center;
  padding:16px;
  z-index:10000;
}
.bcg-modal-backdrop[hidden]{display:none !important;}
.bcg-modal{
  width:min(920px, 100%);
  max-height:min(86vh, 900px);
  background:#fff;
  border-radius:18px;
  border:1px solid rgba(15,23,42,0.14);
  box-shadow:0 20px 60px rgba(15,23,42,0.35);
  overflow:hidden;
  display:flex;
  flex-direction:column;
}
.bcg-modal-head{
  padding:12px 14px;
  display:flex;
  align-items:center;
  gap:10px;
  border-bottom:1px solid rgba(15,23,42,0.10);
}
.bcg-modal-title{
  font-weight:950;
  margin:0;
  font-size:14px;
}
.bcg-modal-body{
  padding:14px;
  overflow:auto;
}
.bcg-modal-foot{
  padding:12px 14px;
  display:flex;
  gap:10px;
  justify-content:flex-end;
  border-top:1px solid rgba(15,23,42,0.10);
  background:rgba(15,23,42,0.02);
}
.bcg-modal-grid{
  display:grid;
  grid-template-columns:1fr;
  gap:10px;
}
.bcg-table-controls{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  align-items:flex-end;
}
.bcg-table-controls .bcg-field{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.bcg-num{
  width:90px;
}
.bcg-table-editor{
  border:1px solid rgba(15,23,42,0.14);
  border-radius:14px;
  overflow:auto;
  background:#fff;
}
.bcg-table-cells{
  display:grid;
  gap:6px;
  padding:10px;
}
.bcg-cell{
  border:1px solid rgba(15,23,42,0.14);
  border-radius:10px;
  padding:8px 10px;
  min-height:40px;
  font-size:13px;
  outline:none;
}
.bcg-cell:focus{
  border-color:rgba(37,99,235,0.55);
  box-shadow:0 0 0 3px rgba(37,99,235,0.14);
}

  
    /* quick color swatches */
    .bcg-swatches{
      display:inline-flex;
      align-items:center;
      gap:6px;
      margin-left:8px;
      vertical-align:middle;
      flex-wrap:wrap;
    }
    .bcg-swatch{
      width:18px;
      height:18px;
      border-radius:7px;
      border:1px solid rgba(15,23,42,0.18);
      cursor:pointer;
      box-shadow:0 6px 14px rgba(15,23,42,0.10);
      padding:0;
    }
    .bcg-swatch:active{ transform:translateY(1px); }

  </style>
</head>

<body>
  <div class="admin-shell">
    <!-- 헤더 슬롯 -->
    <div id="admin-header-slot"></div>

    <div class="admin-main">
      <!-- 메뉴 슬롯 -->
      <aside id="admin-menu-slot" class="admin-sidebar"></aside>

      <!-- 본문 -->
      <main class="admin-content">
        <div class="bcg-wrap">

          <div class="bcg-card">
            <div class="bcg-hero">
              <div>
                <h1 class="bcg-title">블로그 코드 생성</h1>
                <p class="bcg-sub">
                  소제목(H1/H2/H3) + 본문을 넣으면, <b>바로 포스트 관리(BODY_1/2/3 등)에 붙여넣을 수 있는 HTML</b>로 변환해줘.
                  본문 블록은 원하는 만큼 추가할 수 있고, <b>각 블록마다 결과를 따로 복사</b>할 수 있어.
                </p>
              </div>

              <div class="bcg-actions">
                <span class="bcg-pill" id="blockCountPill">블록 0개</span>
                <button class="bcg-btn bcg-btn--primary" id="addBlockBtn" type="button">＋ 블록 추가</button>
              </div>
            </div>

            <div class="bcg-sep"></div>

            <div class="bcg-grid" id="blocks"></div>

            <div class="bcg-sep"></div>

            <div class="bcg-row">
              <span class="bcg-muted">
                ※ 변환 규칙: 빈 줄 기준으로 문단 분리(<code>&lt;p&gt;</code>), 문단 내부 줄바꿈은 <code>&lt;br&gt;</code> 처리. 기본은 HTML 이스케이프(안전). ‘서식/태그 허용’이 켜져 있으면 strong/span/mark/br/table 관련 태그만 허용해.
              </span>
            </div>
          </div>

        </div>
      </main>
    </div>
  </div>

  
  <!-- ✅ Table Builder Modal -->
  <div class="bcg-modal-backdrop" id="tableModal" hidden style="display:none" aria-hidden="true">
    <div class="bcg-modal" role="dialog" aria-modal="true" aria-labelledby="tableModalTitle">
      <div class="bcg-modal-head">
        <h3 class="bcg-modal-title" id="tableModalTitle">표 만들기</h3>
        <span class="bcg-muted">셀을 채우고 “삽입”을 누르면 본문에 표 HTML이 들어가.</span>
        <span class="bcg-right"></span>
        <button class="bcg-btn bcg-mini" type="button" id="tableModalCloseBtn">닫기</button>
      </div>

      <div class="bcg-modal-body">
        <div class="bcg-modal-grid">
          <div class="bcg-table-controls">
            <div class="bcg-field">
              <span class="bcg-label">행</span>
              <input class="bcg-input bcg-num" id="tblRows" type="number" min="1" max="30" value="3">
            </div>
            <div class="bcg-field">
              <span class="bcg-label">열</span>
              <input class="bcg-input bcg-num" id="tblCols" type="number" min="1" max="12" value="3">
            </div>
            <div class="bcg-field">
              <span class="bcg-label">옵션</span>
              <label class="bcg-check" style="margin-top:4px;">
                <input type="checkbox" id="tblHeader" checked>
                첫 줄을 헤더(th)로
              </label>
            </div>
            <div class="bcg-field" style="min-width:240px; flex:1;">
              <span class="bcg-label">캡션(선택)</span>
              <input class="bcg-input" id="tblCaption" placeholder="예) 시대별 왕위 계승 정리">
            </div>

            <button class="bcg-btn bcg-mini bcg-btn--primary" type="button" id="tblRebuildBtn">그리드 생성</button>
          </div>

          <div class="bcg-table-editor">
            <div class="bcg-muted" style="padding:10px 10px 0;">
              팁) 엑셀/시트에서 복사한 텍스트(탭 구분)를 셀에 붙여넣어도 돼.
            </div>
            <div class="bcg-table-cells" id="tblCells"></div>
          </div>

          <div class="bcg-muted">
            생성되는 표는 <code>&lt;table class="cheese-table"&gt;</code> 형태야. 블로그 공통 CSS에서 <code>.cheese-table</code> 스타일을 잡아두면 글마다 통일돼.
          </div>
        </div>
      </div>

      <div class="bcg-modal-foot">
        <button class="bcg-btn bcg-mini" type="button" id="tblInsertBtn">삽입</button>
      </div>
    </div>
  </div>


  <div class="bcg-toast" id="toast"></div>

  <!-- ✅ 공통 JS (헤더/메뉴 슬롯 채움) -->
  <script src="./admin-common.js"></script>

  <script>
    (function(){
      const elBlocks = document.getElementById("blocks");
      const addBtn = document.getElementById("addBlockBtn");
      const pill = document.getElementById("blockCountPill");
      const toast = document.getElementById("toast");

      let seq = 0;

      function showToast(msg){
        toast.textContent = msg;
        toast.classList.add("show");
        clearTimeout(showToast._t);
        showToast._t = setTimeout(()=>toast.classList.remove("show"), 1600);
      }

      // ✅ 안전 이스케이프(기본): &, <, > 만 변환 (따옴표는 그대로 보여주기)
function escapeHtmlLite(s){
  return String(s ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

// ✅ 서식 버튼이 넣는 "일부 태그"만 허용 (나머지는 전부 이스케이프)
// 허용: <strong>, <span style="color:#xxxxxx">, <mark style="background:#xxxxxx">, <br>, <table class="cheese-table">...</table> (thead/tbody/tr/th/td/caption)
function protectAllowedTags_(s){
  const src = String(s ?? "");
  const map = [];
  const re = /<\/?(?:strong|em|u|s)\s*>|<br\s*\/?>|<mark\s+style="background:\s*#[0-9a-fA-F]{3,8}\s*"\s*>|<\/mark>|<span\s+style="color:\s*#[0-9a-fA-F]{3,8}\s*"\s*>|<\/span>|<table\s+class="cheese-table"\s*>|<\/table>|<thead\s*>|<\/thead>|<tbody\s*>|<\/tbody>|<tr\s*>|<\/tr>|<th\s*>|<\/th>|<td\s*>|<\/td>|<caption\s*>|<\/caption>/gi;
  const out = src.replace(re, (m)=>{
    const key = `@@ALLOWED_TAG_${map.length}@@`;
    map.push(m);
    return key;
  });
  return { out, map };
}

function restoreAllowedTags_(s, map){
  let out = String(s ?? "");
  (map || []).forEach((tag, i)=>{
    out = out.split(`@@ALLOWED_TAG_${i}@@`).join(tag);
  });
  return out;
}

function escapeText_(s, allowTags){
  if (!allowTags) return escapeHtmlLite(s);
  const { out, map } = protectAllowedTags_(s);
  const escaped = escapeHtmlLite(out);
  return restoreAllowedTags_(escaped, map);
}

// 빈 줄 기준 문단 분리 → <p>..</p>, 문단 내부 줄바꿈은 <br>
// allowTags=true면 "허용 태그"는 유지하면서 나머지만 이스케이프
function textToParagraphHtml(text, allowTags) {
  // 1. 기본 정리: 줄바꿈 통일 및 보이지 않는 특수문자 제거
  const raw = String(text ?? "").replace(/\r\n/g, "\n").replace(/\u200B/g, '');

  // 2. 2번 이상의 엔터를 기준으로 크게 분리
  const chunks = raw.split(/\n{2,}/g); 

  if (chunks.length === 0) return "";

  return chunks.map(chunk => {
    const trimmedChunk = chunk.trim();
    
    // [예외 1] 테이블 태그인 경우 p태그 없이 그대로 반환
    if (allowTags && /^<table\b/i.test(trimmedChunk) && /<\/table>\s*$/i.test(trimmedChunk)) {
      return escapeText_(trimmedChunk, allowTags);
    }

    // [예외 2] 청크 자체가 하나 이상의 <br> 태그로만 구성된 경우 (p 없이 독립 태그로 반환)
    // 예: "<br>", "<br><br>", "<br/>" 등
    const brOnlyRegex = /^(<br\s*\/?>)+$/i;
    if (brOnlyRegex.test(trimmedChunk.replace(/\s/g, ''))) {
      return trimmedChunk; 
    }

    // 3. 일반적인 문단 내부 줄바꿈 처리
    const lines = chunk.split("\n").map(l => l.trimEnd());
    let processedLines = [];

    for (let i = 0; i < lines.length; i++) {
      let escaped = escapeText_(lines[i], allowTags);
      
      if (i < lines.length - 1) {
        // 이미 줄 끝에 <br>이 있다면 중복 방지, 없으면 추가
        if (/<br\s*\/?>$/i.test(escaped.trim())) {
          processedLines.push(escaped);
        } else {
          processedLines.push(escaped + "<br>");
        }
      } else {
        // 문단 마지막 줄은 <br>을 붙이지 않음 (p태그가 닫히기 때문)
        processedLines.push(escaped.replace(/<br\s*\/?>$/i, ""));
      }
    }

    const content = processedLines.filter(line => line.length > 0).join("\n");
    
    // 내용이 있으면 p태그로 감싸고, 내용이 없으면(엔터만 남은 경우) 독립 br로 처리
    return content ? `<p>${content}</p>` : "<br>";
  }).join("\n");
}
      
// ✅ textarea 선택영역 감싸기(드래그 → 버튼)
function wrapSelection(textarea, left, right){
  if (!textarea) return;
  const s = textarea.selectionStart ?? 0;
  const e = textarea.selectionEnd ?? 0;
  const v = textarea.value ?? "";

  if (s === e){
    const next = v.slice(0, s) + left + right + v.slice(e);
    textarea.value = next;
    const pos = s + left.length;
    textarea.setSelectionRange(pos, pos);
    textarea.focus();
    return;
  }

  const mid = v.slice(s, e);
  const next = v.slice(0, s) + left + mid + right + v.slice(e);
  textarea.value = next;
  textarea.setSelectionRange(s + left.length, e + left.length);
  textarea.focus();
}


// ✅ 선택영역에 "텍스트 삽입"(선택이 있으면 대체)
function insertAtSelection(textarea, insertText){
  if (!textarea) return;
  const s = textarea.selectionStart ?? 0;
  const e = textarea.selectionEnd ?? 0;
  const v = textarea.value ?? "";
  const next = v.slice(0, s) + insertText + v.slice(e);
  textarea.value = next;
  const pos = s + String(insertText).length;
  textarea.setSelectionRange(pos, pos);
  textarea.focus();
}

/* ==========================
   Table Builder Modal
========================== */
const tableModal = document.getElementById("tableModal");
const tableModalCloseBtn = document.getElementById("tableModalCloseBtn");
const tblRowsEl = document.getElementById("tblRows");
const tblColsEl = document.getElementById("tblCols");
const tblHeaderEl = document.getElementById("tblHeader");
const tblCaptionEl = document.getElementById("tblCaption");
const tblRebuildBtn = document.getElementById("tblRebuildBtn");
const tblCellsEl = document.getElementById("tblCells");
const tblInsertBtn = document.getElementById("tblInsertBtn");

let tableCtx = null;

function clampInt_(v, min, max, fallback){
  const n = parseInt(v, 10);
  if (!Number.isFinite(n)) return fallback;
  return Math.max(min, Math.min(max, n));
}

function openTableModal_(ctx){
  tableCtx = ctx || null;
  if (!tableModal) return;
  tableModal.hidden = false;

    tableModal.style.display = 'flex';
  tableModal.setAttribute('aria-hidden','false');
// 초기 그리드 생성
  const r = clampInt_(tblRowsEl?.value, 1, 30, 3);
  const c = clampInt_(tblColsEl?.value, 1, 12, 3);
  buildTableGrid_(r, c);

  // 첫 셀 포커스
  const first = tblCellsEl?.querySelector(".bcg-cell");
  if (first) setTimeout(()=>first.focus(), 0);
}

function closeTableModal_(){
  if (!tableModal) return;
  tableModal.hidden = true;
    tableModal.style.display = 'none';
  tableModal.setAttribute('aria-hidden','true');
tableCtx = null;
}

/* ==========================
   Table Builder Modal - 수정된 그리드 생성 로직
========================== */

function buildTableGrid_(rows, cols){
  if (!tblCellsEl) return;
  tblCellsEl.innerHTML = "";
  tblCellsEl.style.gridTemplateColumns = `repeat(${cols}, minmax(140px, 1fr))`;

  for (let r=0; r<rows; r++){
    for (let c=0; c<cols; c++){
      // input 대신 textarea를 사용하여 여러 줄 입력 가능하게 변경
      const inp = document.createElement("textarea");
      inp.className = "bcg-cell";
      inp.style.height = "60px"; // 기본 높이 설정
      inp.style.resize = "none";  // 그리드 깨짐 방지
      inp.placeholder = (r === 0 && (tblHeaderEl?.checked)) ? `헤더 ${c+1}` : `R${r+1}C${c+1}`;
      inp.setAttribute("data-r", String(r));
      inp.setAttribute("data-c", String(c));

      inp.addEventListener("keydown", (e)=>{
        // 1. 엔터 키: <br> 삽입
        if (e.key === "Enter" && !e.ctrlKey) {
          e.preventDefault();
          const start = inp.selectionStart;
          const end = inp.selectionEnd;
          const val = inp.value;
          
          // 커서 위치에 <br> 삽입
          inp.value = val.substring(0, start) + "<br>" + val.substring(end);
          
          // 커서 위치 조정 (<br> 뒤로)
          inp.selectionStart = inp.selectionEnd = start + 4;
        }
        
        // 2. Ctrl + 엔터 키: 다음 줄(행)로 이동
        if (e.key === "Enter" && e.ctrlKey) {
          e.preventDefault();
          const nr = r + 1;
          const target = tblCellsEl.querySelector(`.bcg-cell[data-r="${nr}"][data-c="${c}"]`);
          if (target) {
            target.focus();
          } else {
            showToast("마지막 행입니다.");
          }
        }
      });
      tblCellsEl.appendChild(inp);
    }
  }
}

function readTableCells_(rows, cols){
  const out = [];
  for (let r=0; r<rows; r++){
    const row = [];
    for (let c=0; c<cols; c++){
      const el = tblCellsEl?.querySelector(`.bcg-cell[data-r="${r}"][data-c="${c}"]`);
      row.push(el ? String(el.value ?? "") : "");
    }
    out.push(row);
  }
  return out;
}

function makeTableHtml_(rows, cols, useHeader, caption, cells){
  const cap = String(caption ?? "").trim();
  const lines = [];
  lines.push('<table class="cheese-table">');
  if (cap) lines.push(`  <caption>${cap}</caption>`);

  if (useHeader && rows >= 1){
    lines.push("  <thead>");
    lines.push("    <tr>");
    for (let c=0; c<cols; c++){
      const v = (cells?.[0]?.[c] ?? "");
      lines.push(`      <th>${v}</th>`);
    }
    lines.push("    </tr>");
    lines.push("  </thead>");
  }

  lines.push("  <tbody>");
  const start = (useHeader ? 1 : 0);
  for (let r=start; r<rows; r++){
    lines.push("    <tr>");
    for (let c=0; c<cols; c++){
      const v = (cells?.[r]?.[c] ?? "");
      lines.push(`      <td>${v}</td>`);
    }
    lines.push("    </tr>");
  }
  lines.push("  </tbody>");
  lines.push("</table>");
  return lines.join("\n");
}

// Wire modal events
if (tableModalCloseBtn) tableModalCloseBtn.addEventListener("click", closeTableModal_);
if (tblRebuildBtn) tblRebuildBtn.addEventListener("click", ()=>{
  const r = clampInt_(tblRowsEl?.value, 1, 30, 3);
  const c = clampInt_(tblColsEl?.value, 1, 12, 3);
  buildTableGrid_(r, c);
});

if (tableModal){
  // backdrop click close
  tableModal.addEventListener("click", (e)=>{
    if (e.target === tableModal) closeTableModal_();
  });
  // esc close
  document.addEventListener("keydown", (e)=>{
    if (e.key === "Escape" && !tableModal.hidden) closeTableModal_();
  });
}

if (tblInsertBtn) tblInsertBtn.addEventListener("click", ()=>{
  if (!tableCtx || !tableCtx.bodyEl) return closeTableModal_();

  // 태그 허용 모드 ON (표는 태그가 필요)
  if (typeof tableCtx.ensureAllowTagsOn_ === "function") tableCtx.ensureAllowTagsOn_();

  const rows = clampInt_(tblRowsEl?.value, 1, 30, 3);
  const cols = clampInt_(tblColsEl?.value, 1, 12, 3);
  const useHeader = !!(tblHeaderEl && tblHeaderEl.checked);
  const caption = tblCaptionEl ? tblCaptionEl.value : "";
  const cells = readTableCells_(rows, cols);

  const tableHtml = makeTableHtml_(rows, cols, useHeader, caption, cells);

  // 표는 "독립 블록"으로 들어가야 <p>로 감싸지지 않음
  const insertText = `\n\n${tableHtml}\n\n`;
  insertAtSelection(tableCtx.bodyEl, insertText);

  if (typeof tableCtx.schedule === "function") tableCtx.schedule();
  if (typeof tableCtx.showToast === "function") tableCtx.showToast("표를 삽입했어.");
  closeTableModal_();
});


      async function copyToClipboard(text){
        try{
          await navigator.clipboard.writeText(text);
          return true;
        }catch(e){
          // fallback
          try{
            const ta = document.createElement("textarea");
            ta.value = text;
            ta.style.position = "fixed";
            ta.style.left = "-9999px";
            ta.style.top = "0";
            document.body.appendChild(ta);
            ta.focus();
            ta.select();
            const ok = document.execCommand("copy");
            document.body.removeChild(ta);
            return ok;
          }catch(e2){
            return false;
          }
        }
      }

      function updatePill(){
        const n = elBlocks.querySelectorAll("[data-bcg-block]").length;
        pill.textContent = `블록 ${n}개`;
      }

      function buildHtml({level, heading, body, allowTags}){
  const tag = (level === "h1" || level === "h2" || level === "h3") ? level : "h2";

  // 제목은 항상 텍스트로 처리 (태그 금지)
  const headText = escapeHtmlLite(String(heading ?? "").trim());

  // 본문은 기본 이스케이프 + (옵션) 일부 태그 허용
  const bodyHtml = textToParagraphHtml(body, !!allowTags);

  // 소제목이 비었으면 본문만 반환 (유연하게)
  const headPart = headText ? `<${tag}>${headText}</${tag}>` : "";
  const parts = [headPart, bodyHtml].filter(Boolean);
  return parts.join("\n");
}

      function createBlock(){
        seq += 1;
        const id = "bcg_" + seq;

        const wrap = document.createElement("div");
        wrap.className = "bcg-card";
        wrap.setAttribute("data-bcg-block", id);

        wrap.innerHTML = `
          <div class="bcg-row">
            <span class="bcg-badge">블록 #${seq}</span>

            <div class="bcg-right bcg-row" style="margin-top:0;">
              <label class="bcg-check" title="체크하면 서식 버튼이 넣는 태그(strong/span/mark/br/table)만 허용해요. 그 외 태그는 자동 이스케이프돼요.">
                <input type="checkbox" data-keep-raw />
                서식/태그 허용
              </label>
              <button class="bcg-btn bcg-mini" type="button" data-generate>코드 생성</button>
              <button class="bcg-btn bcg-mini bcg-btn--primary" type="button" data-copy>복사</button>
              <button class="bcg-btn bcg-mini bcg-btn--danger" type="button" data-remove>삭제</button>
            </div>
          </div>

          <div class="bcg-split" style="margin-top:10px;">
            <div>
              <div class="bcg-row">
                <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; width:100%;">
                  <div style="display:flex; flex-direction:column; gap:6px;">
                    <span class="bcg-label">소제목 레벨</span>
                    <select class="bcg-select" data-level>
                      <option value="h1">H1</option>
                      <option value="h2" selected>H2</option>
                      <option value="h3">H3</option>
                    </select>
                  </div>

                  <div style="display:flex; flex-direction:column; gap:6px; flex:1; min-width:260px;">
                    <span class="bcg-label">소제목 텍스트</span>
                    <input class="bcg-input" data-heading placeholder="예) 숙종의 환국정치, 가계도 흐름 정리" />
                  </div>
                </div>
              </div>

              <div class="bcg-row">
                <div style="display:flex; flex-direction:column; gap:6px; width:100%;">
                  <span class="bcg-label">본문(원문 붙여넣기)</span>

<!-- ✅ 서식 툴바: 드래그(선택) 후 버튼을 누르면 선택영역만 감싸져요 -->
<div class="bcg-toolbar">
  <button class="bcg-btn bcg-mini" type="button" data-fmt="bold">굵게</button>
  <button class="bcg-btn bcg-mini" type="button" data-fmt="br">줄바꿈</button>
  <button class="bcg-btn bcg-mini" type="button" data-fmt="table">표</button>

  <span class="bcg-pill">
    글자색 <input type="color" data-color value="#111827" />

  </span>
  <span class="bcg-swatches" data-color-swatches>
    <button class="bcg-swatch" type="button" data-color-preset="#111827" title="기본(검정)" style="background:#111827;"></button>
    <button class="bcg-swatch" type="button" data-color-preset="#475569" title="회색" style="background:#475569;"></button>
    <button class="bcg-swatch" type="button" data-color-preset="#2563eb" title="파랑" style="background:#2563eb;"></button>
    <button class="bcg-swatch" type="button" data-color-preset="#16a34a" title="초록" style="background:#16a34a;"></button>
    <button class="bcg-swatch" type="button" data-color-preset="#d97706" title="주황" style="background:#d97706;"></button>
    <button class="bcg-swatch" type="button" data-color-preset="#e11d48" title="빨강" style="background:#e11d48;"></button>
  </span>

  <button class="bcg-btn bcg-mini" type="button" data-fmt="color">적용</button>

  <span class="bcg-pill">
    배경 <input type="color" data-bg value="#fde68a" />

  </span>
  <span class="bcg-swatches" data-bg-swatches>
    <button class="bcg-swatch" type="button" data-bg-preset="#fde68a" title="노랑" style="background:#fde68a;"></button>
    <button class="bcg-swatch" type="button" data-bg-preset="#fecdd3" title="핑크" style="background:#fecdd3;"></button>
    <button class="bcg-swatch" type="button" data-bg-preset="#bfdbfe" title="하늘" style="background:#bfdbfe;"></button>
    <button class="bcg-swatch" type="button" data-bg-preset="#bbf7d0" title="연두" style="background:#bbf7d0;"></button>
    <button class="bcg-swatch" type="button" data-bg-preset="#e2e8f0" title="연회색" style="background:#e2e8f0;"></button>
    <button class="bcg-swatch" type="button" data-bg-preset="#ddd6fe" title="연보라" style="background:#ddd6fe;"></button>
  </span>

  <button class="bcg-btn bcg-mini" type="button" data-fmt="bg">적용</button>

  <span class="bcg-muted">※ 서식 버튼(굵게/색/배경/표)을 쓰면 “서식/태그 허용”이 자동으로 켜져.</span>
</div>

<textarea class="bcg-textarea" data-body placeholder="여기에 블로그 원문을 붙여넣어.&#10;빈 줄은 문단으로 처리돼."></textarea>
                  <div class="bcg-muted">팁) 포스트 관리에서 BODY_1/2/3로 나눌 거면, 여기서 블록을 그 개수만큼 만들어서 각각 생성/복사하면 돼.</div>
                </div>
              </div>
            </div>

            <div>
              <div class="bcg-row">
                <div style="display:flex; flex-direction:column; gap:6px; width:100%;">
                  <span class="bcg-label">생성된 HTML</span>
                  <textarea class="bcg-output" data-output readonly placeholder="여기에 결과 HTML이 생성돼."></textarea>
                  <div class="bcg-muted">‘복사’ 버튼을 누르면 이 블록 결과만 클립보드로 복사돼.</div>
                  <div class="bcg-row" style="margin-top:10px;">
                    <span class="bcg-label">미리보기</span>
                    <span class="bcg-muted">※ 서식/태그 허용이 꺼져 있으면 태그는 글자로 보일 수 있어.</span>
                  </div>
                  <div class="bcg-preview" data-preview><div class="bcg-preview-empty">아직 생성된 내용이 없어.</div></div>
                </div>
              </div>
            </div>
          </div>
        `;

        // wire events
        const levelEl = wrap.querySelector("[data-level]");
        const headingEl = wrap.querySelector("[data-heading]");
        const bodyEl = wrap.querySelector("[data-body]");
        const outEl = wrap.querySelector("[data-output]");
        const prevEl = wrap.querySelector("[data-preview]");
        const keepRawEl = wrap.querySelector("[data-keep-raw]");

        const btnGen = wrap.querySelector("[data-generate]");
        const btnCopy = wrap.querySelector("[data-copy]");
        const btnRemove = wrap.querySelector("[data-remove]");

        function regenerate(){
          const html = buildHtml({
            level: levelEl.value,
            heading: headingEl.value,
            body: bodyEl.value,
            allowTags: keepRawEl.checked
          });
          outEl.value = html;
          if (prevEl){
            if (html && html.trim()) prevEl.innerHTML = html;
            else prevEl.innerHTML = '<div class="bcg-preview-empty">아직 생성된 내용이 없어.</div>';
          }
        }

        btnGen.addEventListener("click", () => {
          regenerate();
          showToast("코드를 생성했어.");
        });

        btnCopy.addEventListener("click", async () => {
          // 자동 생성 안 했을 수도 있으니 복사 전에 생성
          if (!outEl.value.trim()) regenerate();
          const ok = await copyToClipboard(outEl.value);
          showToast(ok ? "복사 완료!" : "복사 실패(브라우저 권한을 확인해줘).");
        });

        btnRemove.addEventListener("click", () => {
          wrap.remove();
          updatePill();
          showToast("블록을 삭제했어.");
        });

        // 입력 시 자동 갱신(너무 무겁지 않게 간단 디바운스)
        let t = null;
        function schedule(){
          clearTimeout(t);
          t = setTimeout(regenerate, 180);
        }
        levelEl.addEventListener("change", schedule);
        headingEl.addEventListener("input", schedule);
        bodyEl.addEventListener("input", schedule);
keepRawEl.addEventListener("change", schedule);

// ✅ 서식 툴바(드래그 → 버튼)
const colorEl = wrap.querySelector("[data-color]");
const bgEl = wrap.querySelector("[data-bg]");

let lastSel = { s:0, e:0 };
function saveSel_(){
  try{
    lastSel.s = bodyEl.selectionStart ?? 0;
    lastSel.e = bodyEl.selectionEnd ?? 0;
  }catch(e){}
}
function restoreSel_(){
  try{
    bodyEl.focus();
    bodyEl.setSelectionRange(lastSel.s, lastSel.e);
  }catch(e){}
}
bodyEl.addEventListener("mouseup", saveSel_);
bodyEl.addEventListener("keyup", saveSel_);
bodyEl.addEventListener("select", saveSel_);
bodyEl.addEventListener("focus", saveSel_);

function hasSelection_(){
  const s = lastSel.s ?? 0, e = lastSel.e ?? 0;
  return s !== e;
}

// quick presets: click swatch to set value; if selection exists, apply immediately
wrap.querySelectorAll("[data-color-preset]").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    const v = btn.getAttribute("data-color-preset");
    if (!v) return;
    colorEl.value = v;
    if (hasSelection_()){
      restoreSel_();
      wrapSelection(bodyEl, `<span style="color:${colorEl.value}">`, "</span>");
      schedule();
      showToast("글자색 적용!");
    }else{
      showToast("글자색 선택됨");
      bodyEl.focus();
    }
  });
});

wrap.querySelectorAll("[data-bg-preset]").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    const v = btn.getAttribute("data-bg-preset");
    if (!v) return;
    bgEl.value = v;
    if (hasSelection_()){
      restoreSel_();
      wrapSelection(bodyEl, `<mark style="background:${bgEl.value}">`, "</mark>");
      schedule();
      showToast("배경색 적용!");
    }else{
      showToast("배경색 선택됨");
      bodyEl.focus();
    }
  });
});


function ensureAllowTagsOn_(){
  if (!keepRawEl.checked){
    keepRawEl.checked = true;
    showToast("서식/태그 허용을 켰어.");
  }
}

wrap.querySelectorAll("[data-fmt]").forEach(btn=>{
  btn.addEventListener("click", ()=>{
    const fmt = btn.getAttribute("data-fmt");
    if (!fmt) return;

    // 서식 버튼 사용 시: 허용 태그 모드 자동 ON
    ensureAllowTagsOn_();

    if (fmt === "table"){
      openTableModal_({ bodyEl, ensureAllowTagsOn_: ensureAllowTagsOn_, schedule, showToast });
      return;
    }

    if (fmt === "bold"){
      restoreSel_();
      wrapSelection(bodyEl, "<strong>", "</strong>");
    }else if (fmt === "br"){
      restoreSel_();
      wrapSelection(bodyEl, "<br>", "");
    }else if (fmt === "color"){
      const c = (colorEl && colorEl.value) ? colorEl.value : "#111827";
      restoreSel_();
      wrapSelection(bodyEl, `<span style="color:${c}">`, "</span>");
    }else if (fmt === "bg"){
      const b = (bgEl && bgEl.value) ? bgEl.value : "#fde68a";
      restoreSel_();
      wrapSelection(bodyEl, `<mark style="background:${b}">`, "</mark>");
    }

    schedule();
  });
});

// 초기 1회 생성
regenerate();

        return wrap;
      }

      addBtn.addEventListener("click", () => {
        elBlocks.appendChild(createBlock());
        updatePill();
        showToast("새 블록을 추가했어.");
      });

      // 첫 블록 1개 기본 생성
      elBlocks.appendChild(createBlock());
      updatePill();
    })();
  </script>
</body>
</html>
